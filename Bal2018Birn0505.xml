<?xml version="1.0" encoding="UTF-8"?>
<?xml-model href="balisage-1-3.rng" type="application/xml" schematypens="http://relaxng.org/ns/structure/1.0"?>
<?xml-stylesheet type="text/xsl" href="balisage-proceedings-html.xsl"?>
<article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
    <title>Flattening and unflattening XML markup</title>
    <info>
        <abstract>
            <para>From time to time, it may be necessary or expedient to flatten our XML documents
                by replacing the start- and end-tags of conventional XML content elements with empty
                place-marker elements (variously known as <emphasis role="ital">milestone
                    elements</emphasis> or as <emphasis>Trojan horse markup</emphasis>). When we do,
                we will often wish, later, to restore the content elements we flattened. The purpose
                of this late-breaking presentation is to present a survey of ways to perform the
                task of unflattening or of raising: restoring a conventional XML element structure
                of content elements from a flattened XML document instance (or part of one), and
                comparing different solutions to see what we can learn from them.</para>
        </abstract>
        <author>
            <personname>
                <firstname>David</firstname>
                <othername>J.</othername>
                <surname>Birnbaum</surname>
            </personname>
            <personblurb>
                <para>David J. Birnbaum is Professor and Co-Chair of the Department of Slavic
                    Languages and Literatures at the University of Pittsburgh. He has been involved
                    in the study of electronic text technology since the mid-1980s, has delivered
                    presentations at a variety of electronic text technology conferences, and has
                    served on the board of the Association for Computers and the Humanities, the
                    editorial board of <emphasis role="ital">Markup languages: theory and
                        practice</emphasis>, and the Text Encoding Initiative Council. Much of his
                    electronic text work intersects with his research in medieval Slavic manuscript
                    studies, but he also often writes about issues in the philosophy of
                    markup.</para>
            </personblurb>
            <affiliation>
                <jobtitle>Professor of Slavic Languages and Literatures</jobtitle>
                <orgname>University of Pittsburgh, Pittsburgh, PA</orgname>
            </affiliation>
            <email>djbpitt@gmail.com</email>
        </author>
        <author>
            <personname>
                <firstname>Elisa</firstname>
                <othername>Eileen</othername>
                <surname>Beshero-Bondar</surname>
            </personname>
            <personblurb>
                <para>Elisa Beshero-Bondar is a member of the TEI Technical Council, as well as an
                    Associate Professor of English and Director of the Center for the Digital Text
                    at the University of Pittsburgh at Greensburg. Her projects investigate complex
                    texts such as epics, plays, and multi-volume voyage logs, and she is the founder
                    and organizer of the <link xlink:href="http://digitalmitford.org">Digital
                        Mitford project</link> and its annual coding school.</para>
            </personblurb>
            <affiliation>
                <jobtitle>Associate Professor of English</jobtitle>
                <jobtitle>Director, <link
                        xlink:href="http://www.greensburg.pitt.edu/digital-humanities/center-digital-text"
                        >Center for the Digital Text</link></jobtitle>
                <orgname>University of Pittsburgh at Greensburg</orgname>
            </affiliation>
            <email>ebb8@pitt.edu</email>
        </author>
        <author>
            <personname>
                <firstname>C.</firstname>
                <othername>M.</othername>
                <surname>Sperberg-McQueen</surname>
            </personname>
            <personblurb>
                <para>C. M. Sperberg-McQueen is the founder and principal of <link
                        xlink:href="http://www.blackmesatech.com/">Black Mesa Technologies</link>, a
                    consultancy specializing in helping memory institutions improve the long term
                    preservation of and access to the information for which they are responsible. He
                    served as editor in chief of the TEI Guidelines from 1988 to 2000, and has also
                    served as co-editor of the World Wide Web Consortium's XML 1.0 and XML Schema
                    1.1 specifications.</para>
            </personblurb>
            <affiliation>
                <jobtitle>Founder and Principal</jobtitle>
                <orgname>Black Mesa Technologies</orgname>
            </affiliation>
            <email>cmsmcq@blackmesatech.com</email>
        </author>
    </info>
    <section>
        <title>Overview</title>
        <para>From time to time, it may be necessary or expedient to flatten our XML documents by
            replacing the start- and end-tags of conventional XML content elements with empty
            place-marker elements (variously known as <emphasis role="ital">milestone
                elements</emphasis>, after the milestone technique described in the TEI Guidelines
            for page beginnings, column beginnings, line beginnings, etc. [<xref linkend="tei_p5"
            />], or as <emphasis>Trojan horse markup</emphasis>, after the technique described by
            Steve DeRose [<xref linkend="derose_2004"/>]). When we do, we will often wish, later, to
           restore the content elements we flattened. The three co-authors discovered
            recently that we had each had occasion to perform this task, and that we had undertaken
            it using different techniques.</para>
        <para>The purpose of this late-breaking presentation is to survey multiple ways to
            perform the task of unflattening or of raising: restoring a conventional XML element
            structure of content elements from a flattened XML document instance (or part of one),
            and comparing different solutions to see what we can learn from them. Nothing here is
            profoundly difficult or new, but each of us found it challenging and interesting enough
            that we think it may be worth while to share what we have learned with others.</para>
        <para>In the following sections, we describe first a concrete instance of the task, with
            enough supporting detail to make clear that this is not an academic exercise, but one
            that arose in a concrete project. We then present several approaches to solving the
            problem, including some false starts, which illustrate possible wrong turnings along the
            way. We then discuss and compare the different solutions with respect to coding
            difficulty and costs in space and time.</para>
    </section>
    <section>
        <title>The concrete sample task</title>
        <para>As a concrete example, we can consider the form taken by this task in the <emphasis>Variorum
            Frankenstein [<xref linkend="frankenstein"/>]</emphasis> project edited by the second author. In
            this project, different encodings of the novel deriving from multiple digital sources
            are collated using the software CollateX [<xref linkend="collatex"/>], which
            necessitates flattening the source markup to generate a new XML hierarchy that would
            overlap the original structure. It is necessary to retain markup information in the
            eventual collation output without letting it interfere with the alignment
            process.</para>
        <!--2018-07-02 ebb: I'll continue rewriting here and patch in examples from the frankenData directory. -->
        <para>The process of collation involves comparing around and across structural markup in the source documents. We compare five distinct witnesses of <emphasis>Frankenstein</emphasis>, and divergent passages may include structural boundaries such as paragraph breaks in some editions that are missing in others. The XML output of collation with collateX transforms any input element tags into their text equivalents with escape characters replacing the angle brackets. If we submitted the original edition markup unaltered to the collation process, we knew we would face a challenge in raising well-formed output on the other side, because the critical apparatus is expected to include fragmented start and end tags, as for example, where paragraphs sometimes break inside a reading witness, or only the beginning of a deleted passage in a manuscript witness is comparable to material we see in other witnesses. We wind up with an original start-tag inside one container element and its corresponding original end-tag inside another, and we cannot reconstruct that element without creating overlap. Knowing we were generating an conflicting hierarchy, we opted to flatten the elements in the original edition that we expected would be broken or overlapped by the critical apparatus markup.</para>          
           <para>To illustrate the problem, here is an example from the output of collateX representing a single divergent witness in the <quote>Thomas copy</quote> of <emphasis>Frankenstein</emphasis> before all witnesses align.</para> 
           <programlisting>
               &lt;app&gt;
        &lt;rdg wit="#fThomas"&gt;contortions that ever and anon con&lt;del/&gt;pulsvulsed &amp; deformed
            his un-human features.&lt;p loc="novel1_letter4_chapter4_p133__End"/&gt;&lt;p
            loc="novel1_letter4_chapter4_p134__Start"/&gt;The &lt;/rdg&gt;
    &lt;/app&gt;
    &lt;app type="invariant"&gt;
        &lt;rdg wit="#f1818"&gt;different accidents of life are &lt;/rdg&gt;
        &lt;rdg wit="#f1823"&gt;different accidents of life are &lt;/rdg&gt;
        &lt;rdg wit="#f1831"&gt;different accidents of life are &lt;/rdg&gt;
        &lt;rdg wit="#fMS"&gt;different accidents of life are &lt;/rdg&gt;
        &lt;rdg wit="#fThomas"&gt;different accidents of life are &lt;/rdg&gt;
    &lt;/app&gt;
           </programlisting>  
           <para>When we completed the collation process, we wrote XSLT to separate the five witnesses into separate files to construct new edition files that retain information about variant <quote>hotspots</quote> from the collation. In the first stage of up-conversion from the collation output, all elements are flattened in anticipation of conflicting hierarchies were they to be fully constructed all at once. Here is a sample passage from the Thomas copy edition file showing the reconstructed but flattened elements.</para>
        <programlisting>
            &lt;seg xml:id="C10_app90-fThomas_start"/&gt;contortions that ever and anon con&lt;del loc="fThomas_C10-del_2" ana="start"/&gt;puls&lt;del loc="fThomas_C10-del_2" ana="end"/&gt;vulsed &amp; deformed             his un-human features.&lt;p loc="novel1_letter4_chapter4_p133" ana="end"/&gt;             &lt;p loc="novel1_letter4_chapter4_p134" ana="start"/&gt;The &lt;seg xml:id="C10_app90-fThomas_end"/&gt;
        </programlisting>
       <para>In the passage above, the milestone-style <code>&lt;seg/&gt;</code> elements indicate the start and end points of the variant passage in the Thomas copy, and their <code>@xml:id</code> values indicate the collation unit and numbered <code>&lt;app&gt;</code> element in the collation output: this was the apparatus number 90 that held a lone divergent witness, where the Thomas copy diverges from all the other editions. Inside, the self-closed elements frame a deleted portion of a word, <quote>puls</quote>, and mark the end of paragraph 133 in Chapter 4, followed by the beginning of paragraph 134 in the same chapter. Our task is now to find the best method to raise the flattened elements and give them content. Our task, the use case for this paper, is to raise the structural elements from the original edition, leaving the <code>&lt;seg/&gt;</code> elements flattened. The output will look something like this for paragraphs 133 and 134 in the Thomas edition:</para> 
        <programlisting>
           &lt;p loc="novel1_letter4_chapter4_p133"&gt;. . . I had selected his features as &lt;seg xml:id="C10_app57-fThomas_start"/&gt;beautiful. Beautiful!—Great &lt;seg xml:id="C10_app57-fThomas_end"/&gt;God! His &lt;seg xml:id="C10_app59-fThomas_start"/&gt;yellow &lt;seg xml:id="C10_app59-fThomas_end"/&gt;skin scarcely covered the work of muscles and arteries beneath; his hair &lt;seg xml:id="C10_app63-fThomas_start"/&gt;was of &lt;seg xml:id="C10_app63-fThomas_end"/&gt;a lustrous &lt;seg xml:id="C10_app65-fThomas_start"/&gt;black, &lt;seg xml:id="C10_app65-fThomas_end"/&gt;and &lt;seg xml:id="C10_app67-fThomas_start"/&gt;flowing; &lt;seg xml:id="C10_app67-fThomas_end"/&gt;his teeth of a pearly &lt;seg xml:id="C10_app69-fThomas_start"/&gt;whiteness; &lt;seg xml:id="C10_app69-fThomas_end"/&gt;but these &lt;seg xml:id="C10_app71-fThomas_start"/&gt;luxuriances &lt;seg xml:id="C10_app71-fThomas_end"/&gt;only formed a more horrid contrast with his &lt;seg xml:id="C10_app77-fThomas_start"/&gt;watery eyes, &lt;seg xml:id="C10_app77-fThomas_end"/&gt;that seemed almost of the same colour as the dun white sockets in which they were set, his shrivelled &lt;seg xml:id="C10_app83-fThomas_start"/&gt;complexion, &lt;seg xml:id="C10_app83-fThomas_end"/&gt;
            &lt;del loc="fThomas_C10-del_1"&gt;and&lt;/del&gt; 
            &lt;seg xml:id="C10_app85-fThomas_start"/&gt;straight &lt;seg xml:id="C10_app85-fThomas_end"/&gt;black &lt;seg xml:id="C10_app87-fThomas_start"/&gt;lips. &lt;seg xml:id="C10_app87-fThomas_end"/&gt;
            &lt;seg xml:id="C10_app88-fThomas_start"/&gt;And &lt;seg xml:id="C10_app88-fThomas_end"/&gt;
            &lt;seg xml:id="C10_app89-fThomas_start"/&gt;the &lt;seg xml:id="C10_app89-fThomas_end"/&gt;
            &lt;seg xml:id="C10_app90-fThomas_start"/&gt;contortions that ever and anon con&lt;del loc="fThomas_C10-del_2"&gt;puls&lt;/del&gt;vulsed &amp; deformed
            his un-human features.&lt;/p&gt;
            &lt;p loc="novel1_letter4_chapter4_p134"&gt;The &lt;seg xml:id="C10_app90-fThomas_end"/&gt;different accidents of life are not so changeable as the feelings of human nature. I had worked hard for
        nearly two &lt;seg xml:id="C10_app96-fThomas_start"/&gt;years, &lt;seg xml:id="C10_app96-fThomas_end"/&gt;for the sole purpose of infusing life into an inanimate body. For this I had deprived myself of rest and health. I had desired it with an ardour that far exceeded moderation; but now that I had
        &lt;seg xml:id="C10_app110-fThomas_start"/&gt;finished, the beauty of the dream vanished, &lt;seg xml:id="C10_app110-fThomas_end"/&gt;and breathless horror and disgust filled my heart. . . .&lt;/p&gt;   
        </programlisting>
        <para>When the <code>&lt;seg/&gt;</code> elements are raised, the one set that breaks around the paragraph boundaries will need to be broken into parts around the reconstructed edition elements, like so:
        <programlisting>      
            &lt;p loc="novel1_letter4_chapter4_p133"&gt;. . .I had selected his features as &lt;seg xml:id="C10_app57-fThomas"&gt;beautiful. Beautiful!—Great &lt;/seg&gt;God! His &lt;seg xml:id="C10_app59-fThomas"&gt;yellow &lt;/seg&gt;skin scarcely covered the work of muscles and arteries beneath; his hair &lt;seg xml:id="C10_app63-fThomas"&gt;was of &lt;/seg&gt;a lustrous &lt;seg xml:id="C10_app65-fThomas"&gt;black, &lt;/seg&gt;and &lt;seg xml:id="C10_app67-fThomas"&gt;flowing; &lt;/seg&gt;his teeth of a pearly &lt;seg xml:id="C10_app69-fThomas"&gt;whiteness; &lt;/seg&gt;but these &lt;seg xml:id="C10_app71-fThomas"&gt;luxuriances &lt;/seg&gt;only formed a more horrid contrast with his &lt;seg xml:id="C10_app77-fThomas"&gt;watery eyes, &lt;/seg&gt;that seemed almost of the same colour as the dun white sockets in which they were set, his shrivelled &lt;seg xml:id="C10_app83-fThomas"&gt;complexion, &lt;/seg&gt;
            &lt;del loc="fThomas_C10-del_1"&gt;and&lt;/del&gt; 
            &lt;seg xml:id="C10_app85-fThomas"&gt;straight &lt;/seg&gt;black &lt;seg xml:id="C10_app87-fThomas"&gt;lips. &lt;/seg&gt;
            &lt;seg xml:id="C10_app88-fThomas"&gt;And &lt;/seg&gt;
            &lt;seg xml:id="C10_app89-fThomas"&gt;the &lt;/seg&gt;
            &lt;seg xml:id="C10_app90-fThomas__Pt1"&gt;contortions that ever and anon con&lt;/seg&gt;&lt;del loc="fThomas_C10-del_2"&gt;puls&lt;/del&gt;vulsed &amp; deformed
            his un-human features.&lt;/p&gt;
            &lt;p loc="novel1_letter4_chapter4_p134"&gt;&lt;seg xml:id="C10_app90-fThomas__Pt2"&gt;The &lt;/seg&gt;different accidents of life are not so changeable as the feelings of human nature. . . .&lt;/p&gt;
        </programlisting>
      The split <code>&lt;seg&gt;</code> elements in the passage above now indicate their association with one another with <quote>__Pt1</quote> and <quote>__Pt2</quote> appended to the original value of apparatus and reading witness location.</para>
        <para>Our process of raising the new edition files depends first of all on constructing all the elements that comprise the source edition, before raising the <code>&lt;seg&gt;</code> elements, and that is the task that motivated the experimental transformations tested and discussed in this paper.</para>   
    </section>
    <section xml:id="simplified" xreflabel="Simplified sample data">
        <title>Illustration (simplified data)</title>
        <para>We report below on the application of different raising methods to authentic data from
                <xref linkend="frankenstein"/>, described above, but for illustrative purposes when
            discussing program logic we use a small contrived hierarchical XML sample.<footnote>
                <para>All files discussed in this report, as well as the report itself, are
                    available in <link>https://github.com/djbpitt/raising</link>.</para>
            </footnote> The original input is:</para>
        <figure>
            <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;root&gt;
    &lt;p&gt;This is a &lt;word&gt;paragraph&lt;/word&gt; that contains some stuff.&lt;/p&gt;
    &lt;p&gt;This is another paragraph &lt;phrase&gt;&lt;word&gt;that&lt;/word&gt;
            &lt;word&gt;contains&lt;/word&gt;
            &lt;word&gt;more&lt;/word&gt;&lt;/phrase&gt; stuff.&lt;/p&gt;
&lt;/root&gt;</programlisting>
            <caption>
                <para>Original hierarchical XML</para>
            </caption>
        </figure>
        <para>We modify the Trojan milestone markup method described in <xref linkend="derose_2004"
            /> by putting the <code>@sID</code> and <code>@eID</code> attributes in a namespace, for
            which we bind the prefix <code>th:</code> to the URI
                <code>http://www.blackmesatech.com/2017/nss/trojan-horse</code>. The flattened
            version looks like:</para>
        <figure>
            <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;root xmlns:th="http://www.blackmesatech.com/2017/nss/trojan-horse"&gt;
    &lt;p th:sID="d1e3"/&gt;This is a &lt;word th:sID="d1e5"/&gt;paragraph&lt;word th:eID="d1e5"/&gt; that contains
    some stuff.&lt;p th:eID="d1e3"/&gt;
    &lt;p th:sID="d1e9"/&gt;This is another paragraph &lt;phrase th:sID="d1e11"/&gt;&lt;word th:sID="d1e12"
        /&gt;that&lt;word th:eID="d1e12"/&gt;
    &lt;word th:sID="d1e15"/&gt;contains&lt;word th:eID="d1e15"/&gt;
    &lt;word th:sID="d1e18"/&gt;more&lt;word th:eID="d1e18"/&gt;&lt;phrase th:eID="d1e11"/&gt; stuff.&lt;p th:eID="d1e9"
    /&gt;
&lt;/root&gt;</programlisting>
            <caption>
                <para>Original XML after flattening with Trojan milestones</para>
            </caption>
        </figure>
        <para>The output of raising must match the original XML.</para>
    </section>
    <section>
        <title>Right-sibling traversal (TODO: Michael)</title>
        <para>[Description of the algorithm in the shallow-to-deep.xsl stylesheet on <link
                xlink:href="http://uyghur.ittc.ku.edu">shallow-to-deep.xsl</link>. Possibly two
            versions, for 1.0 and 3.0.]</para>
    </section>
    <section xml:id="inside-out-function" xreflabel="Inside-out recursion">
        <title>Inside-out recursion</title>
        <para>Inside-out recursion works by finding all innermost pairs of Trojan milestones, that
            is, those that do not contain other Trojan milestones.<footnote>
                <para>We call this <emphasis role="ital">inside-out</emphasis>, rather than
                        <emphasis role="ital">bottom-up</emphasis>, because in fully flattened XML
                    all empty elements are on the same hierarchical level, and any original
                    hierarchy has been refactored as containment between Trojan milestones. While
                    the result of raising is constructed in a bottom-up fashion, the nodes to be
                    raised are processed from the inside outward.</para>
            </footnote> They may contain anything else, including <code>text()</code> nodes, empty
            elements that are not Trojan milestones, and container elements. The transformation
            forms all innermost pairs that it finds into container elements and passes the resulting
            new document back into the recursive function, where the innermost pairs of Trojan
            milestones are now outside the newly created container elements. The function recurs
            until there are no more Trojan milestones. The maximum possible depth of recursion is
            equal to the depth in the original (pre-flattening) XML hierarchy.</para>
        <section>
            <title>Flattening</title>
            <para>To test the method on our <xref linkend="simplified"/>, we first flatten the
                original XML with the following XSLT, which converts all tags except the root (which
                must be preserved as a container element to ensure that the XML is well formed) to
                Trojan milestones. The original generic identifier is retained, the start-tag is
                replaced by an empty element that adds a <code>@th:sID</code> attribute with a
                generated value, and the end-tag is replaced by an empty element that adds a
                    <code>th:eID</code> attribute with the same generated value:</para>
            <figure>
                <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:th="http://www.blackmesatech.com/2017/nss/trojan-horse"
    xmlns:math="http://www.w3.org/2005/xpath-functions/math" exclude-result-prefixes="#all"
    version="3.0"&gt;
    &lt;xsl:output method="xml" indent="no"/&gt;
    &lt;xsl:template match="/*"&gt;
        &lt;xsl:copy&gt;
            &lt;xsl:namespace name="th" select="'http://www.blackmesatech.com/2017/nss/trojan-horse'"/&gt;
            &lt;xsl:apply-templates/&gt;
        &lt;/xsl:copy&gt;
    &lt;/xsl:template&gt;
    &lt;xsl:template match="*"&gt;
        &lt;xsl:element name="{name()}"&gt;
            &lt;xsl:attribute name="th:sID" select="generate-id()"/&gt;
        &lt;/xsl:element&gt;
        &lt;xsl:apply-templates/&gt;
        &lt;xsl:element name="{name()}"&gt;
            &lt;xsl:attribute name="th:eID" select="generate-id()"/&gt;
        &lt;/xsl:element&gt;
    &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</programlisting>
                <caption>
                    <para>XSLT to flatten hierarchical XML to Trojan milestones</para>
                </caption>
            </figure>
        </section>
        <section>
            <title>Raising</title>
            <para>The output of the preceding transformation is included in the <xref
                    linkend="simplified"/> section, above. We then reconstruct the hierarchy using
                the inside-out recursive function <code>th:raise()</code> in the following XSLT
                stylesheet:</para>
            <figure>
                <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="3.0"
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:th="http://www.blackmesatech.com/2017/nss/trojan-horse" exclude-result-prefixes="#all"&gt;
    &lt;xsl:output method="xml" indent="no"/&gt;
    &lt;xsl:template match="@* | node()" mode="#all"&gt;
        &lt;xsl:copy copy-namespaces="no"&gt;
            &lt;xsl:apply-templates select="@* | node()"/&gt;
        &lt;/xsl:copy&gt;
    &lt;/xsl:template&gt;
    &lt;xsl:function name="th:raise"&gt;
        &lt;xsl:param name="input" as="document-node()"/&gt;
        &lt;xsl:choose&gt;
            &lt;xsl:when test="exists($input//*[@th:sID eq following-sibling::*[@th:eID][1]/@th:eID])"&gt;
                &lt;xsl:variable name="result" as="document-node()"&gt;
                    &lt;xsl:document&gt;
                        &lt;xsl:apply-templates select="$input" mode="loop"/&gt;
                    &lt;/xsl:document&gt;
                &lt;/xsl:variable&gt;
                &lt;xsl:sequence select="th:raise($result)"/&gt;
            &lt;/xsl:when&gt;
            &lt;xsl:otherwise&gt;
                &lt;xsl:sequence select="$input"/&gt;
            &lt;/xsl:otherwise&gt;
        &lt;/xsl:choose&gt;
    &lt;/xsl:function&gt;
    &lt;xsl:template match="/"&gt;
        &lt;xsl:sequence select="th:raise(.)"/&gt;
    &lt;/xsl:template&gt;
    &lt;xsl:template match="/" mode="loop"&gt;
        &lt;xsl:apply-templates/&gt;
    &lt;/xsl:template&gt;
    &lt;xsl:template match="*[@th:sID eq following-sibling::*[@th:eID][1]/@th:eID]"&gt;
        &lt;!-- innermost start-tag --&gt;
        &lt;xsl:element name="{name()}"&gt;
            &lt;!-- textual content of raised element--&gt;
            &lt;xsl:copy-of
                select="following-sibling::node()[following-sibling::*[@th:eID eq current()/@th:sID]]"
            /&gt;
        &lt;/xsl:element&gt;
    &lt;/xsl:template&gt;
    &lt;!-- nodes inside new wrapper --&gt;
    &lt;xsl:template
        match="node()[preceding-sibling::*[@th:sID][1]/@th:sID eq following-sibling::*[@th:eID][1]/@th:eID]"/&gt;
    &lt;!-- end-tag for new wrapper --&gt;
    &lt;xsl:template
        match="*[@th:eID eq preceding-sibling::*[@th:sID][1]/@th:sID]"/&gt;
&lt;/xsl:stylesheet&gt;</programlisting>
                <caption>
                    <para>XSLT to transform Trojan milestones into container elements</para>
                </caption>
            </figure>
            <para>We turn off indentation (line 5) to avoid deforming the whitespace.
                    <code>@exclude-result-prefixes="#all"</code> is not enough to avoid writing the
                    <code>th:</code> namespace onto the root element of the output, even though the
                namespace in question is not used the output. An unused namespace declaration is
                informationally harmless, but also needlessly distracting, so we suppress it by
                spelling out the identity template (for all modes) and specifying
                    <code>@copy-namespaces="no"</code> on <code>&lt;xsl:copy&gt;</code>inside it
                (lines 6–10).</para>
            <para>Our recursive raising operation (the <code>th:raise()</code> function, lines
                11–26) operates on document nodes, and we need to process the original document node
                of the input file differently from the new document nodes that we create on each
                pass through the recursive function. For that reason, we match the original document
                node in no mode (<code>&lt;xsl:template match="/"&gt;</code>, lines 27–29) and pass
                it into the raising function (<code>&lt;xsl:sequence
                    select="th:raise(.)"/&gt;</code>, line 28).</para>
            <para>The raising function checks for the presence of @th:sID attributes in the input
                that are candidates for raising (<code>&lt;xsl:when
                    test="exists($input//@th:sID)"&gt;</code>, line 14; see the discussion of this
                test in <xref linkend="recursion_challenges"/>). If there aren’t any
                    (<code>&lt;xsl:otherwise&gt;</code>, lines 22–24), the recursion is finished,
                and the function returns the result (<code>&lt;xsl:sequence
                    select="$input"/&gt;</code>, line 23). If there are still <code>@th:sID</code>
                attributes in the text, we create a variable <code>$result</code> (lines 15–19) of
                type document and apply templates inside the newly created document node (line 17).
                After the application of templates is finished, we recur and pass the result into
                another invocation of <code>th:raise()</code> (<code>&lt;xsl:sequence
                    select="th:raise($result)"/></code>, line 20).</para>
            <para>The application of templates within the recursive function begins by applying
                templates to the (newly created) document node in loop mode
                    (<code>&lt;xsl:apply-templates select="$input" mode="loop"/&gt;</code>, line
                17). The matching template (lines 30–32) simply applies templates to its children,
                unlike the template that matches the original document node (in no mode, lines
                27–29), which passes the document into the th:raise() function (line 28), a
                difference in mode that is needed to avoid an endless loop. All other processing is
                the same for both the original document and the interim documents created inside
                    <code>th:raise()</code>, so <code>&lt;xsl:template match="/"
                    mode="loop"&gt;</code> (lines 30–32) is the only modal template, and it applies
                templates to its children in no mode.</para>
            <para>There are three templates that do the actual processing of the innermost elements
                to be raised on each recursion: one that processes the start-tag, one that processes
                the content of the newly raised element, and one that processes the corresponding end-tag:<itemizedlist>
                    <listitem>
                        <para><emphasis role="bold">start-tag:</emphasis> We match elements with an
                            @th:sID attribute that has a value equal to the value of a @th:eID
                            attribute on their first following sibling element that has a @th:eID
                            attribute (line 33). This, then, matches only start-tags that contain
                            nothing but <code>text()</code> nodes and elements that have already
                            been raised (from which attributes in the <code>th:</code> namespacethat
                            were present in the input have been discarded). In other words, it
                            matches only the innermost flattened elements, those that do not contain
                            any other empty flattened elements. We process these hits by creating a
                            container element with the same generic identifier as the start-tag and
                            copying all following-sibling nodes that precede the end-tag that
                            matches the start-tag we’re processing at the moment (lines 35–40). In
                            other words, we copy the content of the newly raised element into
                            it.</para>
                    </listitem>
                    <listitem>
                        <para><emphasis role="bold">nodes inside the new wrapper:</emphasis> We have
                            already copied the content of the newly raised element inside it, which
                            means that we don’t want to process those nodes again, since that would
                            create duplicates. For that reason, we suppress all nodes between the
                            start- and end-tags that we’re processing at the moment by matching them
                            inside an empty <code>&lt;xsl:template&gt;</code> element (lines
                            43–44).</para>
                    </listitem>
                    <listitem>
                        <para><emphasis role="bold">end-tag:</emphasis> Since we create real start-
                            and end-tags when we match the flattened start-tag, we have no more use
                            for the flattened end-tag, so we suppress it by matching it, too, inside
                            an empty <code>&lt;xsl:template&gt;</code> element (line 47).</para>
                    </listitem>
                </itemizedlist></para>
            <para>When the simplified original document is flattened and then raised, as described
                above, the output of the raising operation matches the original input. The preceding
                XSLT does not copy attributes from the Trojan milestones because there aren’t any
                non-Trojan attributes in our simplified example, but where needed, non-Trojan
                attributes can be copied from the Trojan start-tag to the new container by changing
                the element constructor to:</para>
            <figure>
                <programlisting>&lt;xsl:element name="{name()}"&gt;
    &lt;xsl:copy-of select="@* except @th:*"/&gt;
    &lt;xsl:copy-of
        select="following-sibling::node()[following-sibling::*[@th:eID eq current()/@th:sID]]"
    /&gt;
&lt;/xsl:element&gt;</programlisting>
                <caption>
                    <para>Element constructor modified to copy non-Trojan attributes to raised
                        elements</para>
                </caption>
            </figure>
        </section>
        <section>
            <title>Raising <emphasis role="ital">Frankenstein</emphasis></title>
            <para>The Trojan markup in the <emphasis role="ital">Frankenstein</emphasis> data
                differs from that of our simplified test sample. Specifically, Trojan start-tags in
                    <emphasis role="ital">Frankenstein</emphasis> have an <code>@ana</code>
                attribute with the value <code>start</code>, end-tags have an <code>@ana</code>
                attribute with the value <code>end</code>, and start- and end-tags are paired by
                sharing a unique value of a <code>@loc</code> attribute. The output requirements are
                to remove the <code>@ana</code> attribute and refactor the <code>@loc</code>
                attribute as an <code>@xml:id</code> attribute. We do that with:</para>
            <figure>
                <programlisting>&lt;xsl:element name="{name()}"&gt;
    &lt;xsl:attribute name="xml:id" select="@loc"/&gt;
    &lt;xsl:copy-of
        select="following-sibling::node()[following-sibling::*[@loc eq current()/@loc]]"/&gt;
&lt;/xsl:element&gt;</programlisting>
                <caption>
                    <para>Element constructor to refactor <code>@loc</code> as <code>@xml:id</code>
                        <emphasis role="ital">Frankenstein</emphasis></para>
                </caption>
            </figure>
            <para>We match Trojan start-tags, (raised) element content, and end-tags in <emphasis
                    role="ital">Frankenstein</emphasis> with the following XPath patterns:</para>
            <figure>
                <programlisting>&lt;xsl:template match="*[@ana eq 'start'][@loc eq following-sibling::*[@ana eq 'end'][1]/@loc]"&gt;</programlisting>
                <caption>
                    <para>XPath expression to match Trojan start-tags in <emphasis role="ital"
                            >Frankenstein</emphasis></para>
                </caption>
            </figure>
            <figure>
                <programlisting>&lt;xsl:template match="node()[preceding-sibling::*[@ana eq 'start'][1]/@loc eq following-sibling::*[@ana eq 'end'][1]/@loc]"/&gt;</programlisting>
                <caption>
                    <para>XPath expression to match the content of raised elements in <emphasis
                            role="ital">Frankenstein</emphasis></para>
                </caption>
            </figure>
            <figure>
                <programlisting>&lt;xsl:template match="*[@ana eq 'end'][@loc eq preceding-sibling::*[@ana eq 'start'][1]/@loc]"/&gt;</programlisting>
                <caption>
                    <para>XPath expression to match Trojan end-tags in <emphasis role="ital"
                            >Frankenstein</emphasis></para>
                </caption>
            </figure>
        </section>
        <section>
            <title>XSLT 1.0</title>
            <para>TODO: rewrite using a recursive named-template call for 1.0 with result element
                extension</para>
        </section>
    </section>
    <section>
        <title>An XSLT 3.0 solution using accumulators (TODO: Michael)</title>
        <para>[To be written. I am assuming that we can find a way to use accumulators to handle
            this.]</para>
    </section>
    <section>
        <title>Global search and replace using regular expressions</title>
        <para>It is not possible to parse arbitrary XML with regular expressions (regex), but it is
            not difficult to identify and process Trojan milestones.<footnote>
                <para>In terms of the Chomsky hierarchy, XML is a Type 2 (context-free) grammar and
                    regular expressions are a Type 3 (regular) grammar. Parsing a context-free
                    grammar, which permits recursion, requires a stack, which is not available in
                    regular grammars. While some modern regular expression implementations support
                    back-referencing and recursion and thus go beyond the limitations of a Chomsky
                    regular grammar, whether methods that rely on these extensions should be
                    considered regular-expression parsing is unclear (this is a theoretical issue),
                    as is the role of legibility in evaluating the suitability of the method to the
                    task (this is a practical concern).</para>
            </footnote></para>
        <para>The following regex matches Trojan start-tags:</para>
        <figure>
            <programlisting>(&lt;[^&gt;]+?)th:sID\s*?=\s*['"]\w+?['"](.*?)\/(&gt;)</programlisting>
            <caption>
                <para>Regex to match Trojan start-tags</para>
            </caption>
        </figure>
        <para>The regex works as follows (in <emphasis role="ital">dot-all</emphasis> mode, that is,
            where dot also matches <code>\n</code>):<itemizedlist>
                <listitem>
                    <para>The first capture group matches everything from the beginning of a tag
                        that contains a <code>@th:sID</code> attribute until that attribute name.
                        This necessarily includes the space that precedes the attribute name, as
                        well as any attributes that might also precede it.</para>
                </listitem>
                <listitem>
                    <para>We do not capture any part of the <code>th:sID</code> attribute: the
                        attribute name, the equal sign (with optional whitespace before or after),
                        the quotation mark value delimiter (single or double), the attribute value
                        (all characters up to the closing value delimiter), and the closing value
                        delimiter. As long as the <code>th:sID</code> and <code>th:eID</code> values
                        are created with the XPath <code>generate-id()</code> function, they cannot
                        contain single or double quotation marks (<code>generate-id()</code> creates
                        only values that are XML names), so we do not need to verify that the
                        opening and closing delimiters match each other lexically.<footnote>
                            <para>“The returned identifier must consist of ASCII alphanumeric
                                characters and must start with an alphabetic character. Thus, the
                                string is syntactically an XML name.” [<xref linkend="xpath"/>,
                                    <link
                                    xlink:href="https://www.w3.org/TR/xpath-functions-31/#func-generate-id"
                                    >§14.5.4</link>]</para>
                        </footnote></para>
                </listitem>
                <listitem>
                    <para>The second capture group captures everything following the
                            <code>@th:sID</code> attribute up to the <code>/&gt;</code> that marks
                        the end of the tag.</para>
                </listitem>
                <listitem>
                    <para>We do not capture the <code>/</code> before the closing <code>&gt;</code>.<footnote>
                            <para>Forward slash has to be escaped in some regex implementations, but
                                not in others. Escaping where it is not required does no
                                harm.</para>
                        </footnote></para>
                </listitem>
                <listitem>
                    <para>The third capture group captures the closing <code>&gt;</code>.</para>
                </listitem>
            </itemizedlist></para>
        <para>We replace all matches with the following replacement pattern:</para>
        <figure>
            <programlisting>\1\2\3</programlisting>
            <caption>
                <para>Replacement pattern for Trojan start-tags</para>
            </caption>
        </figure>
        <para>The regex to match Trojan end-tags is similar to the one for start-tags, and because
            real end-tags cannot contain attributes, we do not need to match or copy them. We
            capture the opening <code>&lt;</code> separately from whatever follows it, so that we
            can write a <code>/</code> into the replacement after it. The regex is:</para>
        <figure>
            <programlisting>(&lt;)(\S+?)\s+[^&gt;]*?th:eID=['"]\w+['"][^&gt;]*?\/(&gt;)</programlisting>
            <caption>
                <para>Regex to match Trojan end-tags</para>
            </caption>
        </figure>
        <para>and the replacement pattern is:</para>
        <figure>
            <programlisting>\1/\2\3</programlisting>
            <caption>
                <para>Replacement pattern for Trojan end-tags</para>
            </caption>
        </figure>
        <para>This method will incorrectly apply the replacement to matching patterns within XML
            comments and CDATA marked sections. With insincere apologies for disappointing Regex
            Edge-Case Bounty Hunters, coping with matches in these contexts, which would not
            naturally appear in our data, is not a goal in our work.<footnote>
                <para>Similarly, we rely on the use of <code>th:</code> as the namespace prefix and
                        <code>th:sID</code> and <code>th:eID</code> as the attribute names for our
                    Trojan attributes. Changing these assumptions is not a problem as long as the
                    regex is changed to match.</para>
            </footnote></para>
        <para>A more serious limitation of this method is that because it is not XML-aware, it can
            be used only in situations where raising is guaranteed not to create overlap. For
            example, given input like:<figure>
                <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;root xmlns:th="http://www.blackmesatech.com/2017/nss/trojan-horse"&gt;
    &lt;page th:sID="page1"/&gt;
    &lt;para th:sID="para1"/&gt;Content on page 1 in paragraph 1 
    &lt;page th:eID="page1"/&gt;
    &lt;page th:sID="page2"/&gt;Content on page 2 in para 1 
    &lt;para th:eID="para1"/&gt;
    &lt;para th:sID="para2"/&gt;Content on page 2 in para 2
    &lt;para th:eID="para2"/&gt;
    &lt;page th:eID="page2"/&gt;
&lt;/root&gt;</programlisting>
                <caption>
                    <para>XML that cannot be unflattened without creating overlap</para>
                </caption>
            </figure> the result of converting all Trojan milestones to real start- and end-tags
            would be: <figure>
                <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;root&gt;
    &lt;page&gt;
        &lt;para&gt;Content on page 1 in paragraph 1 
    &lt;/page&gt;
    &lt;page&gt;Content on page 2 in para 1 
        &lt;/para&gt;
        &lt;para&gt;Content on page 2 in para 2&lt;/para&gt;
    &lt;/page&gt;
&lt;/root&gt;</programlisting>
                <caption>
                    <para>Invalid (overlapping) result of converting all Trojan milestones to real
                        start and end tags</para>
                </caption>
            </figure> The resulting document is not well-formed because the pages and paragraphs
            overlap. It is, however, possible to raise just pages but not paragraphs, or just
            paragraphs but not pages, without creating overlap, and the result would be
            well-formed.</para>
        <para>[In order to time this, we will want to perform these tasks with sed, emacs in batch
            mode, and/or Perl or Python.]</para>
    </section>
    <section>
        <title>Pull parsing in Python</title>
        <para>The Python <code>xml.dom.pulldom</code> module that can be used to stream an XML
            document past an event handler that can be instructed to raise a flattened hierarchy.<footnote>
                <para>The authors are grateful to Ronald Haentjens Dekker for bringing this method
                    to our attention. The example at his
                        <link>https://github.com/rhdekker/python_xml_pull_parser_example</link>
                    GitHub repository is the model for the examples here.</para>
            </footnote> The result of pull parsering can be fashioned into output in two ways, as a
            string or as XML. With string output, this method is comparable to the regex replacement
            strategy described above: it passes all events through unchanged except for Trojan
            milestones, which it replaces with regular XML start- and end-tags. Because the output
            construction is not XML-aware, it has the same limitations as the regex approach: most
            significantly, it is capable of creating output that includes overlap, and that
            therefore is not well formed XML. With XML output, though, we use
                <code>xml.dom.minidom</code> to create XML elements within a DOM structure, and the
            result is necessarily well-formed. Pull parsing operates as a single depth-first
            traversal, which is to say that it begins at the document node and touches each element
            only once. With string output, the procedure can create write output as it handles each
            event; with XML output, it is necessary to maintain the current context in a
            stack.</para>
        <section>
            <title>String output</title>
            <para>The following Python 3 code replaces Trojan milestones with strings equivalent to
                real XML start- and end-tags:</para>
            <figure>
                <programlisting>from xml.dom.pulldom import CHARACTERS, START_ELEMENT, parseString, END_ELEMENT

output = []
with open('flattened.xml') as input:
    for event, node in parseString(input.read()):
        if event == START_ELEMENT:
            if node.hasAttribute('th:eID'):
                output.append('&lt;/')
            else: # Trojan start tags and non-Trojan
                output.append('&lt;')
            output.append(node.nodeName)
            for attname, attvalue in node.attributes.items():
                if not(attname.startswith('th:')):
                    output.append(' ' + attname + '="' + attvalue + '"')
            output.append('>')
        if event == END_ELEMENT:
            if not node.hasAttribute('th:sID') and not node.hasAttribute('th:eID'):
                output.append('&lt;/' + node.localName + '>')
        elif event == CHARACTERS:
            output.append(node.data)
print("".join(output))</programlisting>
                <caption>
                    <para>Python code that constructs the XML output as a string</para>
                </caption>
            </figure>
            <para>We create an empty list to hold the output, read in the source, and examine each
                event. In this simplified example, we process only <code>START_ELEMENT</code>,
                    <code>END_ELEMENT</code>, and <code>CHARACTERS</code>, as follows:</para>
            <itemizedlist>
                <listitem>
                    <para><code>START_ELEMENT.</code> Trojan milestones with <code>@th:eID</code>
                        attributes are flattened end-tags, so when we encounter one, we output
                            <code>&lt;/</code>; for other <code>START_ELEMENT</code> events we
                        output only <code>&lt;</code>. We follow this with the gi
                            (<code>node.nodeName</code>) and then iterate over the attributes. For
                        each non-Trojan attribute, we output a space, the attribute name, an equal
                        sign, and the attribute value in quotation marks. Finally, we output the
                        closing <code>&gt;</code>.</para>
                </listitem>
                <listitem>
                    <para><code>END_ELEMENT.</code> Although Trojan milestones are single tags, they
                        fire both <code>START_ELEMENT</code> and <code>END_ELEMENT</code> events.
                        Since we process all Trojan milestones at their <code>START_ELEMENT</code>
                        events, we ignore their <code>END_ELEMENT</code> events. For other
                            <code>END_ELEMENT</code> events, we create a regular end-tag.</para>
                </listitem>
                <listitem>
                    <para><code>CHARACTERS.</code> We add character data content to the
                        output.</para>
                </listitem>
            </itemizedlist>
            <para>We are parsing the input XML in an XML-aware manner, which is reasonably robust,
                but we are constructing the output XML as a string, which is not. See below for a
                discussion of the limitations.</para>
            <para>[TODO: namespace-aware, instead of string-matching on attribute names?]</para>
        </section>
    </section>
    <section>
        <title>Some things that can go wrong</title>
        <para>Each of the methods described above comes with its own complications. Some of these
            are challenges that can be overcome, others are limitations in what the method can
            manage, and others are deal-breakers that show that the method is not ultimately
            suitable for realistic use cases. In this section we review briefly the complications
            for each method.</para>
        <section>
            <title>EBB’s implementation of right-sibling recursion (TODO: Elise)</title>
            <para>EBB’s implementation of right-sibling recursion, with analysis and
                discussion.</para>
        </section>
        <section>
            <title>Right-sibling traversal (TODO: Michael)</title>
            <para>MSM’s bugs include a failure to specify the correct mode on an apply-templates
                call, which meant that processing slipped out of the special mode and into default
                mode, and many nodes appeared repeatedly in the input: tenfold increase in size of
                document, and more.</para>
        </section>
        <section xml:id="recursion_challenges" xreflabel="Inside-out recursion challenges">
            <title>Inside-out recursion</title>
            <para>The two principal pitfalls with inside-recursion are <emphasis role="ital">double
                    processing</emphasis> and <emphasis role="ital">endless
                recursion</emphasis>.</para>
            <section>
                <title>Double processing</title>
                <para>When a start-tag is matched and raised, the nodes that belong inside it are
                    copied into it inside the template that matches the start-tag. Because the nodes
                    being copied are also candidates for the application of templates in the current
                    pass through the function, we need to match them (along with the end-tag) in an
                    empty <code>&lt;xsl:template&gt;</code> in order to avoid outputting them twice.
                    Otherwise they would be copied when the start-tag is matched and then processed
                    again when templates are applied to them in their own right.</para>
            </section>
            <section>
                <title>Endless recursion</title>
                <para>Recursion requires an exit condition to avoid falling into an endless loop. In
                    an early version of the code, the recursive function tested for the presence of
                    Trojan milestone attributes, and if there weren’t any, it concluded that all
                    raising had been completed and stopped the recursion. This test fails in
                    situations where there are Trojan elements that cannot be raised without
                    creating overlap. Avoiding the endless loop in such situations requires a more
                    complex test, not just for the presence of Trojan attributes, but for the
                    presence of those that can be raised without creating overlap. In our simplified
                    sample, instead of testing for <code>exists($input//@th:sID)</code>, we test for
                    elements that can be raised without risk of overlap with:</para>
                <figure>
                    <programlisting>exists($input//*[@th:sID eq following-sibling::*[@th:eID][1]/@th:eID])</programlisting>
                    <caption>
                        <para>Test for Trojan milestones that can be raised without creating
                            overlap</para>
                    </caption>
                </figure>
                <para>Endless recursion is not an issue in situations where complete raising would
                    not create overlap. This is the case with our original simplified sample, where
                    the XML with Trojan markup was created by flattening original hierarchical XML,
                    and since the original could not have had overlap, it can be reconstructed
                    safely. Endless recursion is also not a problem when we raise only a subset of
                    the markup that is guaranteed not to overlap. For example, if we have
                    tessellated page and paragraph hierarchies over a prose text, where both pages
                    and paragraphs have been flattened, we cannot fully raise all instances both
                    types of elements if doing so would create overlap. But if our markup convension
                    is that pages cannot overlap with pages and paragraphs cannot overlap with
                    paragraphs, we can modify the raising routine to raise only the pages or only
                    the paragraphs. See also <xref linkend="tessellated"/>, where we discuss an
                    alternative approach to raising with data of this type.</para>
            </section>
        </section>
        <section>
            <title>Accumulators (TODO: Michael)</title>
            <para>MSM's single combat with accumulators</para>
        </section>
        <section>
            <title>Regex</title>
            <para>The only challenge to writing the regex (aside from the risk of inadvertently
                creating XML that is not well-formed because of overlap, which is discussed above)
                is anticipating variation in the markup. For example, an XML start-tag with a single
                attribute looks like <code>&lt;gi attname="value"&gt;</code>, but it allows optional
                whitespace around the equal sign and before the closing <code>&gt;</code>
                delimiter—but not between the opening <code>&lt;</code> delimiter and the generic
                identifier, and not between the <code>/</code> and the <code>&gt;</code> at the end
                of a self-closing empty tag. Where it allows whitespace, it allows any amount of any
                combination of whitespace characters.</para>
            <para>Within the context of a single project, the easiest way to deal with the allowable
                variation is not to allow it, that is, to enforce rigorous consistency even where
                XML syntax does not require it. But because rigorous consistency is difficult to
                achieve without computational validation, we opted for a more robust regex—that is,
                one more accepting of variation, even though allowing for variation made the regex
                harder to read and develop.</para>
        </section>
        <section>
            <title>Python pull parsing (TODO: David)</title>
            <para>The Python pull parser reads the input XML as XML and responds to parse events. We
                handle <code>START_ELEMENT</code>, <code>END_ELEMENT</code>, and
                    <code>CHARACTERS</code>, and ignore other events, and we use XML-aware methods
                to access attributes. With respect to managing the input, then, this is a reasonably
                robust strategy. The quality of the output handling depends on whether we create
                output as a string or as an XML DOM.</para>
            <section>
                <title>String output</title>
                <para>Creating XML output as a string is a brittle strategy. Not only is it
                    susceptible to writing overlapping tags or the same reason as the regex method
                    described earlier, but we also explicitly wrap attribute values in double-quote
                    characters (<code>"</code>). This will produce results that are not well-formed
                    if the attribute value happens to have contained the double-quote character
                    originally. Python has an escape mechanism that is capable of dealing with
                    awkwardly nested single- and double-quote characters in strings, as does XML,
                    but the Python escape strategy is different from the XML one, and the code to
                    perform the string manipulation needed to mediate between the two is difficult
                    to read and write. For that reason, it is safer to use XML methods to create the
                    XML output as a (necessarily well-formed) DOM tree, which can then be
                    serialized, instead of creating the output directly as a string.</para>
            </section>
        </section>
    </section>
    <section>
        <title>Comparison (David, with input from Michael and Elisa in subsections)</title>
        <para>The inside-out recursive approach (both the function-based XSLT 3.0 version and
            named-template-based XSLT 1.0 one) is tail-recursive, which means that an XSLT processor
            that performs tail-call optimization will not be at risk for running out of stack space.
            In cases where tail-call optimization is not available, the maximum depth of recursion
            is equal to the <emphasis role="ital">depth</emphasis> of the deepest Trojan element in
            the input hierarchy. The right-sibling traversal approach (both the XSLT 3.0 and the
            XSLT 1.0 versions) is also tail-recursive (TODO: Michael, is this correct?), and with an
            XSLT parser that does not perform tail-call optimization, it requires stack space equal
            to the maximum <emphasis role="ital">width</emphasis> of the widest hierarchical
            level.</para>
        <para>Insofar as an open-source XSLT 3.0 processor that performs tail-call optimization is
            freely available in the open-source, platform-independent Saxon-HE product [<xref
                linkend="saxon"/>], the difference in stack requirements between the two methods has
            not been a consideration for our purposes. But insofar as XML documents of the sort that
            are of interest to digital humanists are typically wider than they are deep, users who
            are unable to employ an XSLT processor that performs tail-call optimization may favor
            inside-out processing over right-sibling traversal because inside-out processing is
            likely to require less stack space.</para>
        <para>(TODO: Michael: I find the inside-out approach simpler, that is, easier to understand,
            but I don’t know whether that’s because it is simpler, or because of the greater
            familiarity that comes with having developed it. If it is objectively simpler, should we
            mention that in our comparison?)</para>
        <para>TODO: Unassigned: [Measurement of time and space complexity running all solutions on
            the same data (as large as we can manage—e.g., all of <emphasis role="ital"
                >Frankenstein</emphasis>, or an artificial document containing 10 or 100 copies of
                <emphasis role="ital">Frankenstein</emphasis>).]</para>
        <para>TODO: Unassigned: [Time complexity is easy enough to measure; space complexity may be
            harder, but we may be able to find ways. I believe that the Unix tool <emphasis
                role="bold">top</emphasis> gives the current memory usage of a task, so the
            information is certainly available.]</para>
        <para>TODO Unassigned: [One reason I would like to have multiple XSLT 1.0 solutions is so
            that we can test performance in more than one implementation: <emphasis role="bold"
                >xsltproc</emphasis>, <emphasis role="bold">Xalan</emphasis>, and browser XSLT
            engines, if we can figure out how to persuade a browser to do the work.</para>
        <para>TODO Unassigned: [My prediction a priori is that using <emphasis role="bold"
                >sed</emphasis>, <emphasis role="bold">emacs</emphasis>, <emphasis role="bold"
                >perl</emphasis>, or <emphasis role="bold">Python</emphasis> to make the changes
            with regular expressions will be much faster than using XSLT. Without XSLT, it will be
            much easier to produce output that’s not well-formed; it would be good to document how
            many attempts are needed before our sed script is producing well-formed output, and how
            many more are needed before it’s both well formed and correct. djb: I spent about an
            hour crafting and debugging the regex expressions for the start and end tags. It
            produces well-formed output with my baby sample, recreating the original document
            (before flattening) faithfully. I look forward to the Frankentest!]</para>
    </section>
    <section>
        <title>Conclusion (TODO: Unassigned)</title>
        <para>[what do we say here? djb: The conclusion of my micro-pipelining paper last year may
            be applicable here, too. It reads: “None of the methods described here is new, but their
            explicit juxtaposition, comparison, and evaluation in a tutorial context based on real
            use cases has clarified much about micropipelining for the author, and, it is hoped, for
            the reader, as well.”]</para>
    </section>
    <appendix xml:id="tessellated">
        <title>Raising tessellated hierarchies (TODO: djb)</title>
        <para>Raising tessellated hierarchies is a common requirement for hierarchy <emphasis
                role="ital">inversion</emphasis>.<footnote>
                <para><emphasis role="ital">Tessellated</emphasis> structures cover an entire domain
                    with the same pattern without gaps or self-overlap, much as mosaic tiles might
                    cover an entire floor.</para>
            </footnote> Consider a simple print document that can be understood as containing a
            sequence of pages or a sequence of paragraphs, where each sequence fully covers the
            content without self-overlap, but where the two different element types overlap in a way
            that makes it impossible to use container elements for both. One typical XML workflow
            with such structures involves encoding one hierarchy with XML container elements and the
            other with milestones. For example, a TEI novel transcribed from an original source
            might be structured with <code>&lt;div&gt;</code> elements for chapters, which contain
                <code>&lt;head&gt;</code> elements for chapter titles and <code>&lt;p&gt;</code>
            elements for paragraphs, with page beginnings encoded as empty <code>&lt;pb/&gt;</code>
            elements. If is later becomes necessary to operate on the pages as units, we can
                <emphasis role="ital">invert</emphasis> the markup by transforming the
            page-beginning milestones into page container elements, while flattening the elements
            that demarcate chapters, titles, and paragraphs.</para>
        <para>The method described in this appendix differs from those described above because it
            works only where the hierarchy being raised is tessellated. That outcome requirement
            invites the use of <code>&lt;xsl:for-each-group&gt;</code>, which partitions its entire
            domain exhaustively into groups. The same property that makes
                <code>&lt;xsl:for-each-group&gt;</code> suitable for a situation where an entire
            text may be partitioned into tessellated paragraphs or tessellated pages makes it a poor
            choice for the contexts described in the body of this report, where new container
            elements must be created only around small islands of content.</para>
        <para>[TODO: DJB use case from <link>http://suprasliensis.obdurodon.org</link>]</para>
    </appendix>
    <bibliography>
        <title>Works cited</title>
        <bibliomixed xml:id="collatex" xreflabel="CollateX"><emphasis role="ital">CollateX: software
                for collating textual sources.</emphasis>
            <link>https://collatex.net/-</link></bibliomixed>
        <bibliomixed xml:id="derose_2004" xreflabel="DeRose 2004">DeRose, Steve. 2004. “Markup
            Overlap: a review and a horse.” Presented at Extreme Markup Languages 2004. Montréal,
            Québec, August 2-6, 2004.
            <link>http://xml.coverpages.org/DeRoseEML2004.pdf</link></bibliomixed>
        <bibliomixed xml:id="tei_p5" xreflabel="TEI P5">P5: <emphasis role="ital">Guidelines for
                electronic text encoding and interchange.</emphasis>
            <link>http://www.tei-c.org/guidelines/P5/</link></bibliomixed>
        <bibliomixed xml:id="frankenstein" xreflabel="Variorum Frankenstein"><emphasis role="ital"
                >Pittsburgh</emphasis> Frankenstein <emphasis role="ital">Project.</emphasis>
            <link>https://github.com/PghFrankenstein/Pittsburgh_Frankenstein</link></bibliomixed>
        <bibliomixed xml:id="saxon" xreflabel="Saxon-HE">Saxon-HE (home edition).
                <link>http://saxon.sourceforge.net/</link></bibliomixed>
        <bibliomixed xml:id="xpath" xreflabel="XPath functions"><emphasis role="ital">XPath and
                XQuery functions and operators 3.1 W3C recommendation 21 March 2017.</emphasis>
            <link>https://www.w3.org/TR/xpath-functions-31/</link></bibliomixed>
    </bibliography>
</article>
