<?xml version="1.0" encoding="UTF-8"?>
<?xml-model href="balisage-1-3.rng" type="application/xml" schematypens="http://relaxng.org/ns/structure/1.0"?>
<?xml-stylesheet type="text/xsl" href="balisage-proceedings-html.xsl"?>
<article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
    <title>Flattening and unflattening XML markup</title>
    <info>
        <abstract>
            <para>From time to time, it may be necessary or expedient to flatten our XML documents
                by replacing the start- and end-tags of conventional XML content elements with empty
                place-marker elements (variously known as <emphasis role="ital">milestone
                    elements</emphasis> or as <emphasis>Trojan horse markup</emphasis>). When we do,
                we will often wish, later, to restore the content elements we flattened. The purpose
                of this late-breaking presentation is to present a survey of ways to perform the
                task of unflattening or of raising: restoring a conventional XML element structure
                of content elements from a flattened XML document instance (or part of one), and
                comparing different solutions to see what we can learn from them.</para>
        </abstract>
        <author>
            <personname>
                <firstname>David</firstname>
                <othername>J.</othername>
                <surname>Birnbaum</surname>
            </personname>
            <personblurb>
                <para>David J. Birnbaum is Professor and Co-Chair of the Department of Slavic
                    Languages and Literatures at the University of Pittsburgh. He has been involved
                    in the study of electronic text technology since the mid-1980s, has delivered
                    presentations at a variety of electronic text technology conferences, and has
                    served on the board of the Association for Computers and the Humanities, the
                    editorial board of <emphasis role="ital">Markup languages: theory and
                        practice</emphasis>, and the Text Encoding Initiative Council. Much of his
                    electronic text work intersects with his research in medieval Slavic manuscript
                    studies, but he also often writes about issues in the philosophy of
                    markup.</para>
            </personblurb>
            <affiliation>
                <jobtitle>Professor of Slavic Languages and Literatures</jobtitle>
                <orgname>University of Pittsburgh, Pittsburgh, PA</orgname>
            </affiliation>
            <email>djbpitt@gmail.com</email>
        </author>
        <author>
            <personname>
                <firstname>Elisa</firstname>
                <othername>E.</othername>
                <surname>Beshero-Bondar</surname>
            </personname>
            <personblurb>
                <para>Elisa Beshero-Bondar is a member of the TEI Technical Council, as well as an
                    Associate Professor of English and Director of the Center for the Digital Text
                    at the University of Pittsburgh at Greensburg. Her projects investigate complex
                    texts such as epics, plays, and multi-volume voyage logs, and she is the founder
                    and organizer of the <link xlink:href="http://digitalmitford.org">Digital
                        Mitford project</link> and its annual coding school.</para>
            </personblurb>
            <affiliation>
                <jobtitle>Associate Professor of English</jobtitle>
                <jobtitle>Director, <link
                        xlink:href="http://www.greensburg.pitt.edu/digital-humanities/center-digital-text"
                        >Center for the Digital Text</link></jobtitle>
                <orgname>University of Pittsburgh at Greensburg</orgname>
            </affiliation>
            <email>ebb8@pitt.edu</email>
        </author>
        <author>
            <personname>
                <firstname>C.</firstname>
                <othername>M.</othername>
                <surname>Sperberg-McQueen</surname>
            </personname>
            <personblurb>
                <para>C. M. Sperberg-McQueen is the founder and principal of <link
                        xlink:href="http://www.blackmesatech.com/">Black Mesa Technologies</link>, a
                    consultancy specializing in helping memory institutions improve the long term
                    preservation of and access to the information for which they are responsible. He
                    served as editor in chief of the TEI Guidelines from 1988 to 2000, and has also
                    served as co-editor of the World Wide Web Consortium's XML 1.0 and XML Schema
                    1.1 specifications.</para>
            </personblurb>
            <affiliation>
                <jobtitle>Founder and Principal</jobtitle>
                <orgname>Black Mesa Technologies</orgname>
            </affiliation>
            <email>cmsmcq@blackmesatech.com</email>
        </author>
    </info>
    <section>
        <title>Overview</title>
        <para>From time to time, it may be necessary or expedient to flatten our XML documents by
            replacing the start- and end-tags of conventional XML content elements with empty
            place-marker elements (variously known as <emphasis role="ital">milestone
                elements</emphasis>, after the milestone technique described in the TEI Guidelines
            for page beginnings, column beginnings, line beginnings, etc. [<xref linkend="tei_p5"
            />], or as <emphasis>Trojan horse markup</emphasis>, after the technique described by
            Steve DeRose [<xref linkend="derose_2004"/>]; to avoid
            over-stressing the particular syntax used, we will
            generally call them <emphasis>markers</emphasis>). When we
            do flatten our documents, we will often wish, later, to
            restore the content elements we flattened. The three co-authors discovered recently that
            we had each had occasion to perform this task, and that we had undertaken it using
            different techniques.</para>
        <para>The purpose of this late-breaking presentation is to survey multiple ways to perform
            the task of unflattening or of raising: restoring a conventional XML element structure
            of content elements from a flattened XML document instance (or part of one), and
            comparing different solutions to see what we can learn from them. Nothing here is
            profoundly difficult or new, but each of us found it challenging and interesting enough
            that we think it may be worth while to share what we have learned with others.</para>
        <para>In the following sections, we describe first a concrete instance of the task, with
            enough supporting detail to make clear that this is not an academic exercise, but one
            that arose in a concrete project. We then present several approaches to solving the
            problem, including some false starts, which illustrate possible wrong turnings along the
            way. We then discuss and compare the different solutions with respect to coding
            difficulty and costs in space and time. </para>
        <para>In the discussions which follow, we adopt the following
        terminology in an attempt to avoid unnecessary confusion.
        First, we distinguish content elements (marked by standard XML
        start- and end-tags) from virtual elements (marked by markers).
        <variablelist>
          <varlistentry>
            <term>content element</term>
            <listitem>
              <para>a conventional XML element marked by start- and
              end-tags with (possibly empty) content between them, or
              by a sole-tag.  Cf. <emphasis
              role="ital">marker</emphasis>.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>virtual element</term>
            <listitem>
              <para>a <quote>logical</quote> element marked by start-
              and end-markers.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>marker</term>
            <listitem>
              <para>an empty XML elements serving to mark the start or
              end of a virtual element.</para>
            </listitem>
          </varlistentry>
        </variablelist>
        </para>
        <para>We are interested in two processes which shift between
        content elements and virtual elements marked by markers:
        <variablelist>    
          <varlistentry>
            <term>flattening</term>
            <listitem>
              <para>the process of replacing the start- and end-tags
              of (selected) content elements with corresponding start-
              and end-markers.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>raising (aka <emphasis>unflattening</emphasis>)</term>
            <listitem>
              <para>the process of replacing (selected) pairs of start- and end-markers
              of (selected) content elements with corresponding start-
              and end-markers.</para>
            </listitem>
          </varlistentry>
        </variablelist>
        </para>
        <para>Our approaches for raising flattened XML may be
        categorized according to the following parameters:<itemizedlist>
        <listitem>
          <para>Whether they read their input as XML or as a string.</para>
        </listitem>
        <listitem>
          <para>Whether they construct their output as XML or as a string.</para>
        </listitem>
        <listitem>
          <para>For those that read the input as XML, whether they process the flattened
          content from left to right or from the inside outward.</para>
        </listitem>
      </itemizedlist>
        </para>
        <para>The methods that work with the input and output as XML are typically recursive
            (whether the recursion is implemented through functions or
            templates<!--
            Michael, is this correct for the methods you are
            developing?
            --><!--*
            It is.  At least, the right-sibling traversal is
            recursive; whether it's necessarily recursive, I
            don't know.
            [Pause.]
            The accumulator approach, on the other hand, is not
            recursive.              
            *-->),
            and the recursion follows one of two patterns:<itemizedlist>
                <listitem>
                    <para>The input is traversed from left to right
                    and the output is constructed in start-tag/end-tag
                    order in a single pass.</para>
                    <para>We refer to the traversal of the input as
                    left-to-right, rather than as depth-first, because
                    insofar as the markers and the content of the
                    virtual elements they mark are all siblings, the
                    input document typically has no meaningful depth
                    and there is no difference between depth- and
                    breadth-first traversal.</para>
                    <para>We refer to the construction as tag-order
                    because the construction of the virtual elements
                    begins in the order of their start-markers and
                    ends in the order of their end-markers.
                    </para>
                </listitem>
                <listitem>
                  <para>The input is traversed left-to-right in multiple passes;                 
                  on each pass the innermost or bottom-most virtual
                  element(s) are raised to become content elements.</para>
                  <para>We refer to the construction as bottom up
                  because in each parent-child pair of the ouput, the
                  construction of the child begins and ends before the
                  construction of the parent begins.</para>
                  <para>As in the preceding case, because the input
                  has no meaningful depth, it is more appropriate to describe the traversal
                  without using hierarchical terms, although bottom-up is an appropriate way
                  to refer to the construction of the hierarchical output.</para>
                </listitem>
            </itemizedlist></para>

        <para>With respect to those parameters, the methods discussed below may be classified as
            follows:</para>
        <table>
            <thead>
                <tr>
                    <th>Method</th>
                    <th>Input type</th>
                    <th>Input traversal</th>
                    <th>Output type</th>
                    <th>Output construction</th>
                    <th>Recursive / stack?</th>
                    <th>Passes</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <th>Right-sibling traversal</th>
                    <td>XML</td>
                    <td>Depth-first (first child, then first following sibling)</td>
                    <td>XML</td>
                    <td>Left to right</td>
                    <td>Recursive template application</td>
                    <td>Single pass</td>
                </tr>
                <tr>
                    <th>Inside-out recursion</th>
                    <td>XML</td>
                    <td>Inside out</td>
                    <td>XML</td>
                    <td>Bottom up</td>
                    <td>Recursive function calls</td>
                    <td>Multiple passes (<emphasis>n</emphasis> =
                    height of tree of virtual elements)</td>
                </tr>
                <tr>
                    <th>Accumulator</th>
                    <td>XML</td>
                    <td>Pre- and post-traversal</td>
                    <td>XML</td>
                    <td>Left to right</td>
                    <td>Stack maintained as an accumulator; no
                    recursive calls</td>
                    <td>Single pass</td>
                </tr>
                <tr>
                    <th>Regex replacement</th>
                    <td>String</td>
                    <td>Left to right</td>
                    <td>String</td>
                    <td>Left to right</td>
                    <td>No</td>
                    <td>Single pass</td>
                </tr>
                <tr>
                    <th>Python pull parser 1</th>
                    <td>XML</td>
                    <td>Left to right</td>
                    <td>String</td>
                    <td>Left to right</td>
                    <td>No</td>
                    <td>???</td>
                </tr>
                <tr>
                    <th>Python pull parser 2</th>
                    <td>XML</td>
                    <td>Left to right</td>
                    <td>XML</td>
                    <td>Top down</td>
                    <td>Yes</td>
                    <td>???</td>
                </tr>
            </tbody>
        </table>
    </section>
    <section>
        <title>Raising <emphasis role="ital">Frankenstein</emphasis></title>
        <para>As a concrete example, we can consider the form taken by this task in the
                <emphasis>Variorum Frankenstein [<xref linkend="frankenstein"/>]</emphasis> project
            edited by the second author. In this project, different encodings of the novel deriving
            from multiple digital sources are collated using the software CollateX [<xref
                linkend="collatex"/>], which necessitates flattening
            the source markup, as in its output CollateX generates a
            new XML hierarchy that would overlap the original structure. It is necessary to retain
            markup information in the eventual collation output without letting it interfere with
            the alignment process.</para>
        <para>The process of collation involves comparing around and across structural markup in the
            source documents. We compare five distinct witnesses of
            <emphasis>Frankenstein</emphasis>, and divergent passages may include structural
            boundaries such as paragraph breaks in some editions that are missing in others. The XML
            output of collation with collateX transforms any input element tags into their text
            equivalents with escape characters replacing the angle brackets. If we submitted the
            original edition markup unaltered to the collation process, we knew we would face a
            challenge in raising well-formed output on the other side, because the critical
            apparatus is expected to include fragmented start and end tags, as for example, where
            paragraphs sometimes break inside a reading witness, or only the beginning of a deleted
            passage in a manuscript witness is comparable to material we see in other witnesses. We
            wind up with an original start-tag inside one container element and its corresponding
            original end-tag inside another, and we cannot reconstruct that element without creating
            overlap. Knowing we were generating a conflicting hierarchy, we opted to flatten the
            elements in the original edition that we expected would be broken or overlapped by the
            critical apparatus markup.</para>
        <para>To illustrate the problem, here is an example from the output of CollateX representing
            a single divergent witness in the <quote>Thomas copy</quote> of
            <emphasis>Frankenstein</emphasis> before all witnesses align.
            (Line breaks have been introduced within markup here to make
            the lines shorter.)     
        </para>
        <figure>
            <programlisting>&lt;app&gt;
    &lt;rdg wit="#fThomas"&gt;contortions that ever and anon 
    con&lt;del loc="fThomas_C10-del_2" ana="start"/&gt;puls&lt;del
        loc="fThomas_C10-del_2" ana="end"/&gt;vulsed &amp;amp;
        deformed his un-human features.&lt;p
        loc="novel1_letter4_chapter4_p133__End"/&gt;&lt;p
        loc="novel1_letter4_chapter4_p134__Start"/&gt;The &lt;/rdg&gt;
&lt;/app&gt;
&lt;app type="invariant"&gt;
    &lt;rdg wit="#f1818"&gt;different accidents of life are &lt;/rdg&gt;
    &lt;rdg wit="#f1823"&gt;different accidents of life are &lt;/rdg&gt;
    &lt;rdg wit="#f1831"&gt;different accidents of life are &lt;/rdg&gt;
    &lt;rdg wit="#fMS"&gt;different accidents of life are &lt;/rdg&gt;
    &lt;rdg wit="#fThomas"&gt;different accidents of life are &lt;/rdg&gt;
&lt;/app&gt;</programlisting>
            <caption>
                <para>Sample collation output</para>
            </caption>
        </figure>
        <para>After we completed the collation process, we wrote XSLT to separate the five witnesses
            into separate files that could be used in a new edition files that retained information
            about variant moment of variation (<emphasis role="ital">hotspots</emphasis>) in the
            collation. A prerequisite of up-conversion from the collation outputis to flatten all
            markup in anticipation of conflicting hierarchies were all logical containers to be
            represented simultaneously with regular start- and end-tags. Here is a sample passage
            from the Thomas copy edition file showing the reconstructed but flattened
            elements:</para>
        <figure>
            <programlisting>&lt;seg xml:id="C10_app90-fThomas_start"/&gt;contortions that ever and anon 
con&lt;del loc="fThomas_C10-del_2" ana="start"/&gt;puls&lt;del
    loc="fThomas_C10-del_2" ana="end"/&gt;vulsed
&amp;amp; deformed  his un-human features.&lt;p
loc="novel1_letter4_chapter4_p133" ana="end"/&gt; 
&lt;p loc="novel1_letter4_chapter4_p134" ana="start"
/&gt;The &lt;seg xml:id="C10_app90-fThomas_end"/&gt;</programlisting>
            <caption>
                <para>Sample reconstruction of the Thomas file, with flattened markup</para>
            </caption>
        </figure>
        <para>In the passage above, the empty <code>&lt;seg&gt;</code> elements indicate the start
            and end points of the variant passage in the Thomas copy. Their partially shared
                <code>@xml:id</code> values coindex them while pointing to the collation unit and
            numbered <code>&lt;app&gt;</code> element in the collation output; the trailing
            underscore separator and the string <code>start</code> or <code>end</code> distinguish
            start- from end-tags. In this example, <code>&lt;seg
                xml:id="C10_app90-fThomas_start"/&gt;</code> means that this is the start of a
            variant from apparatus unit 90, where the Thomas copy diverges from a reading shared by
            all of the other editions.</para>
        <para>Within the Trojan <code>&lt;seg&gt;</code> container, the first two Trojan
                <code>&lt;del&gt;</code> elements frame a deleted portion of a word
                (<quote>puls</quote>), and the third marks the end of paragraph 133 in Chapter 4,
            followed by the beginning of paragraph 134 in the same chapter. The use of attributes
            here differs from that with the <code>&lt;seg&gt;</code> elements; the shared
                <code>@loc</code> attribute identifies the location and coindexes the start- and
            end-tags, and the <code>@ana</code> attribute marks the attribute as either a start-tag
            or an end-tag.<footnote>
                <para>Using different formats for the Trojan markup of different flattened elements
                    makes it easy to raise one group of flattened element types while leaving
                    another in its flattened stage. Alternatively, we could have used the same
                    attributes for all Trojan elements and made the distinction instead at the
                    processing stage by specifying then which ones we wanted to raise.</para>
            </footnote></para>
        <para>The use case that serves as a testing ground for the comparison of raising methods in
            this report is to raise the structural elements from the original edition (such as
                <code>&lt;p&gt;</code> and <code>&lt;del&gt;</code>), while leaving the
                <code>&lt;seg&gt;</code> elements flattened. The output will look something like the
            following for the ending of paragraph 133 and the start of paragraph 134 in the Thomas
            edition:</para>
        <figure>
            <programlisting>&lt;p loc="novel1_letter4_chapter4_p133"&gt; …
&lt;seg xml:id="C10_app90-fThomas_start"/&gt;contortions
that ever and anon
con&lt;del loc="fThomas_C10-del_2"&gt;puls&lt;/del&gt;vulsed
&amp;amp; deformed his un-human features.&lt;/p&gt;
&lt;p loc="novel1_letter4_chapter4_p134"&gt;The &lt;seg
xml:id="C10_app90-fThomas_end"/&gt;
different accidents of life are not so changeable as
the feelings of human nature … &lt;/p&gt;</programlisting>
            <caption>
                <para>The sample passage above, after raising
                structural elements (and reflowing)</para>
            </caption>
        </figure>
        <para>When, later in the production process, we raise the <code>&lt;seg&gt;</code> elements,
            we avoid overlap by fragmenting the one that spans a paragraph boundary into two
            parts:</para>
        <figure>
            <programlisting>&lt;p loc="novel1_letter4_chapter4_p133"&gt; …
&lt;seg xml:id="C10_app90-fThomas__Pt1"&gt;contortions 
that ever and anon
con&lt;/seg&gt;&lt;del loc="fThomas_C10-del_2"
&gt;puls&lt;/del&gt;vulsed
&amp;amp; deformed his
un-human features.&lt;/p&gt;
&lt;p loc="novel1_letter4_chapter4_p134"
&gt;&lt;seg xml:id="C10_app90-fThomas__Pt2"&gt;The
&lt;/seg&gt; different accidents of life are
not so changeable as the feelings of human
nature … &lt;/p&gt;</programlisting>
            <caption>
                <para>Because raising <code>&lt;seg&gt;</code> would create overlap, we split the
                    element into parts</para>
            </caption>
        </figure>
        <para>The split <code>&lt;seg&gt;</code> elements in the passage above now indicate their
            association with one another with <quote>__Pt1</quote> and <quote>__Pt2</quote> appended
            to the original value of the apparatus and reading witness location.</para>
        <para>Our process of raising the new edition files thus entails the following steps:<orderedlist>
                <listitem>
                    <para>Flatten all markup</para>
                </listitem>
                <listitem>
                    <para>Reconstruct (raise) the structural elements from the source edition (e.g.,
                            <code>&lt;p&gt;</code>, <code>&lt;del&gt;</code>)</para>
                </listitem>
                <listitem>
                    <para>Raise the <code>&lt;seg&gt;</code> elements, which indicate moment of
                        variation in the collation, splitting the raised elements into parts where
                        that is required to avoid creating overlap</para>
                </listitem>
            </orderedlist> The experimental transformations tested and discussed in this report
            focus primarily on the middle of these three steps, raising the structural
            markup.</para>
    </section>

    <section xml:id="simplified" xreflabel="Simplified sample data">
        <title>Illustration (simplified data)</title>
        <para>We report below on the application of different raising methods to authentic data from
                <xref linkend="frankenstein"/>, described above, but for illustrative purposes when
            discussing program logic we use a small contrived hierarchical XML sample.<footnote>
                <para>All files discussed in this report, as well as the report itself, are
                    available in <link>https://github.com/djbpitt/raising</link>.</para>
            </footnote> The original input is:</para>
        <figure>
            <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;root&gt;
    &lt;p&gt;This is a
        &lt;word&gt;paragraph&lt;/word&gt;
        that contains some
	stuff.&lt;/p&gt;
    &lt;p&gt;This is another paragraph
        &lt;phrase&gt;&lt;word&gt;that&lt;/word&gt;
            &lt;word&gt;contains&lt;/word&gt;
            &lt;word&gt;more&lt;/word&gt;&lt;/phrase&gt;
        stuff.&lt;/p&gt;
&lt;/root&gt;</programlisting>
            <caption>
                <para>Original hierarchical XML</para>
            </caption>
        </figure>
        <para>We modify the Trojan milestone markup method described in <xref linkend="derose_2004"
            /> by putting the <code>@sID</code> and <code>@eID</code> attributes in a namespace, for
            which we bind the prefix <code>th:</code> to the URI
                <code>http://www.blackmesatech.com/2017/nss/trojan-horse</code>. The flattened
            version looks like:</para>
        <figure>
            <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;root xmlns:th="http://www.blackmesatech.com/2017/nss/trojan-horse"&gt;
    &lt;p th:sID="d1e3"/&gt;This is a
        &lt;word th:sID="d1e5"/&gt;paragraph&lt;word th:eID="d1e5"/&gt;
        that contains some
        stuff.&lt;p th:eID="d1e3"/&gt;
    &lt;p th:sID="d1e9"/&gt;This is another paragraph
        &lt;phrase th:sID="d1e11"/&gt;&lt;word th:sID="d1e12"
            /&gt;that&lt;word th:eID="d1e12"/&gt;
            &lt;word th:sID="d1e15"
            /&gt;contains&lt;word th:eID="d1e15"/&gt;
            &lt;word th:sID="d1e18"
            /&gt;more&lt;word th:eID="d1e18"/&gt;&lt;phrase
            th:eID="d1e11"/&gt;
       stuff.&lt;p th:eID="d1e9"
    /&gt;
&lt;/root&gt;</programlisting>
            <caption>
                <para>Original XML after flattening with Trojan milestones</para>
            </caption>
        </figure>
        <para>The output of raising must match the original XML.</para>
    </section>

    <section>
      <title>Right-sibling traversal</title>
        <para>One way to construct content elements from flattened XML is to use a "right-sibling
            traversal" of the input tree, in which each container element calls apply-template only
            on its first child, and each template passes control to its immediate right
            sibling.</para>
        <para>In this appraoch the task of constructing the content element is assigned to the
            template which matches the Trojan-Horse start-tag. The template for such an empty
            element has the following structure:</para>
        <figure>
            <programlisting><![CDATA[<xsl:template match="*[@th:sID]" mode="shallow-to-deep">
    <xsl:variable name="ns" select="namespace-uri()"/>
    <xsl:variable name="ln" as="xs:string" select="local-name()"/>
    <xsl:variable name="sID" as="xs:string" select="@th:sID"/>
    
    <!--* 1: handle this element *-->
    <xsl:copy>
      <xsl:copy-of select="@* except @th:sID"/>
      <xsl:apply-templates select="following-sibling::node()[1]"
                   mode="shallow-to-deep">
      </xsl:apply-templates>
    </xsl:copy>
      
    <!--* 2: continue after this element *-->
    <xsl:apply-templates select="following-sibling::*[@th:eID = $sID 
                         and namespace-uri()=$ns
                         and local-name()=$ln]
                         /following-sibling::node()[1]"
                 mode="shallow-to-deep">
    </xsl:apply-templates>
</xsl:template>]]></programlisting>
            <caption>
                <para>Template for empty element</para>
            </caption>
        </figure>
        <para>First, it creates an element with the name and attributes given by the Trojan Horse
            start element, then it passes control not to its immediately following sibling (which is
            either the first child of the virtual element or its Trojan Horse end tag) but to the
            node immediately to the right of the Trojan Horse end tag.</para>
        <para> Each child of the virtual element copies itself into the element being created. The
            templates for <code>text()</code> nodes, comments, processing instructions, and any
            content elements present in the input all have essentially the same structure:</para>
        <figure>
            <programlisting><![CDATA[<xsl:copy-of select="."/>
<xsl:apply-templates select="following-sibling::node()[1]"
                 mode="shallow-to-deep"/>]]></programlisting>
            <caption>
                <para>Template for <code>text()</code> nodes, comments, processing instructions, and
                    content elements</para>
            </caption>
        </figure>
        <para>(If content elements can contain further Trojan-Horse markup at other levels of the
            tree, the <code>copy-of</code> should be replaced by a shallow copy and a recursive
                <code>apply-templates select="child::node()[1]</code>.) </para>
        <para>When a Trojan-Horse end-tag is encountered, the contents of the virtual element whose
            end it marks have now all been accumulated, and the right-sibling traversal of the input
            should stop. The template for Trojan end-tags will thus look like this:</para>
        <figure>
            <programlisting><![CDATA[<xsl:template match="*[@th:eID]" mode="shallow-to-deep">
        
    <!--* no action necessary *-->
    <!--* we do NOT recur to our right.  We leave it to our parent to do 
        that. *-->      
    
</xsl:template>]]></programlisting>
            <caption>
                <para>Template for Trojan end tags</para>
            </caption>
        </figure>
	
        <para><emphasis>For purposes of performance measurement, we
        expect to implement this algorithm in both XSLT 1.0 and XSLT
        2.0 or 3.0.  At the time of submission, no XSLT 1.0 version is
	available.</emphasis></para>
    </section>

    <section xml:id="inside-out-function" xreflabel="Inside-out recursion">
        <title>Inside-out recursion</title>
        <para>Inside-out recursion works by finding all innermost pairs of Trojan milestones, that
            is, those that do not contain other Trojan milestones.<footnote>
                <para>We call this <emphasis role="ital">inside-out</emphasis>, rather than
                        <emphasis role="ital">bottom-up</emphasis>, because in fully flattened XML
                    all empty elements are on the same hierarchical level, and any original
                    hierarchy has been refactored as containment between Trojan milestones. While
                    the result of raising is constructed in a bottom-up fashion, the nodes to be
                    raised are processed from the inside outward.</para>
            </footnote> They may contain anything else, including <code>text()</code> nodes, empty
            elements that are not Trojan milestones, and container elements. The transformation
            forms all innermost pairs that it finds into container elements and passes the resulting
            new document back into the recursive function, where the innermost pairs of Trojan
            milestones are now outside the newly created container elements. The function recurs
            until there are no more Trojan milestones. The maximum possible depth of recursion is
            equal to the depth in the original (pre-flattening) XML hierarchy.</para>
        <section>
            <title>Flattening</title>
            <para>To test the method on our <xref linkend="simplified"/>, we first flatten the
                original XML with the following XSLT, which converts all tags except the root (which
                must be preserved as a container element to ensure that the XML is well formed) to
                Trojan milestones. The original generic identifier is retained, the start-tag is
                replaced by an empty element that adds a <code>@th:sID</code> attribute with a
                generated value, and the end-tag is replaced by an empty element that adds a
                    <code>th:eID</code> attribute with the same generated value:</para>
            <figure>
                <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:th="http://www.blackmesatech.com/2017/nss/trojan-horse"
    xmlns:math="http://www.w3.org/2005/xpath-functions/math" exclude-result-prefixes="#all"
    version="3.0"&gt;
    &lt;xsl:output method="xml" indent="no"/&gt;
    &lt;xsl:template match="/*"&gt;
        &lt;xsl:copy&gt;
            &lt;xsl:namespace name="th" select="'http://www.blackmesatech.com/2017/nss/trojan-horse'"/&gt;
            &lt;xsl:apply-templates/&gt;
        &lt;/xsl:copy&gt;
    &lt;/xsl:template&gt;
    &lt;xsl:template match="*"&gt;
        &lt;xsl:element name="{name()}"&gt;
            &lt;xsl:attribute name="th:sID" select="generate-id()"/&gt;
        &lt;/xsl:element&gt;
        &lt;xsl:apply-templates/&gt;
        &lt;xsl:element name="{name()}"&gt;
            &lt;xsl:attribute name="th:eID" select="generate-id()"/&gt;
        &lt;/xsl:element&gt;
    &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</programlisting>
                <caption>
                    <para>XSLT to flatten hierarchical XML to Trojan milestones</para>
                </caption>
            </figure>
        </section>
        <section>
            <title>Raising</title>
            <para>The output of the preceding transformation is included in the <xref
                    linkend="simplified"/> section, above. We then reconstruct the hierarchy using
                the inside-out recursive function <code>th:raise()</code> in the following XSLT
                stylesheet:</para>
            <figure>
                <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="3.0"
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:th="http://www.blackmesatech.com/2017/nss/trojan-horse" exclude-result-prefixes="#all"&gt;
    &lt;xsl:output method="xml" indent="no"/&gt;
    &lt;xsl:template match="@* | node()" mode="#all"&gt;
        &lt;xsl:copy copy-namespaces="no"&gt;
            &lt;xsl:apply-templates select="@* | node()"/&gt;
        &lt;/xsl:copy&gt;
    &lt;/xsl:template&gt;
    &lt;xsl:function name="th:raise"&gt;
        &lt;xsl:param name="input" as="document-node()"/&gt;
        &lt;xsl:choose&gt;
            &lt;xsl:when test="exists($input//*[@th:sID eq following-sibling::*[@th:eID][1]/@th:eID])"&gt;
                &lt;xsl:variable name="result" as="document-node()"&gt;
                    &lt;xsl:document&gt;
                        &lt;xsl:apply-templates select="$input" mode="loop"/&gt;
                    &lt;/xsl:document&gt;
                &lt;/xsl:variable&gt;
                &lt;xsl:sequence select="th:raise($result)"/&gt;
            &lt;/xsl:when&gt;
            &lt;xsl:otherwise&gt;
                &lt;xsl:sequence select="$input"/&gt;
            &lt;/xsl:otherwise&gt;
        &lt;/xsl:choose&gt;
    &lt;/xsl:function&gt;
    &lt;xsl:template match="/"&gt;
        &lt;xsl:sequence select="th:raise(.)"/&gt;
    &lt;/xsl:template&gt;
    &lt;xsl:template match="/" mode="loop"&gt;
        &lt;xsl:apply-templates/&gt;
    &lt;/xsl:template&gt;
    &lt;xsl:template match="*[@th:sID eq following-sibling::*[@th:eID][1]/@th:eID]"&gt;
        &lt;!-- innermost start-tag --&gt;
        &lt;xsl:element name="{name()}"&gt;
            &lt;!-- textual content of raised element--&gt;
            &lt;xsl:copy-of
                select="following-sibling::node()[following-sibling::*[@th:eID eq current()/@th:sID]]"
            /&gt;
        &lt;/xsl:element&gt;
    &lt;/xsl:template&gt;
    &lt;!-- nodes inside new wrapper --&gt;
    &lt;xsl:template
        match="node()[preceding-sibling::*[@th:sID][1]/@th:sID eq following-sibling::*[@th:eID][1]/@th:eID]"/&gt;
    &lt;!-- end-tag for new wrapper --&gt;
    &lt;xsl:template
        match="*[@th:eID eq preceding-sibling::*[@th:sID][1]/@th:sID]"/&gt;
&lt;/xsl:stylesheet&gt;</programlisting>
                <caption>
                    <para>XSLT to transform Trojan milestones into container elements</para>
                </caption>
            </figure>
            <para>We turn off indentation (line 5) to avoid deforming the whitespace.
                    <code>@exclude-result-prefixes="#all"</code> is not enough to avoid writing the
                    <code>th:</code> namespace onto the root element of the output, even though the
                namespace in question is not used the output. An unused namespace declaration is
                informationally harmless, but also needlessly distracting, so we suppress it by
                spelling out the identity template (for all modes) and specifying
                    <code>@copy-namespaces="no"</code> on <code>&lt;xsl:copy&gt;</code>inside it
                (lines 6–10).</para>
            <para>Our recursive raising operation (the <code>th:raise()</code> function, lines
                11–26) operates on document nodes, and we need to process the original document node
                of the input file differently from the new document nodes that we create on each
                pass through the recursive function. For that reason, we match the original document
                node in no mode (<code>&lt;xsl:template match="/"&gt;</code>, lines 27–29) and pass
                it into the raising function (<code>&lt;xsl:sequence
                    select="th:raise(.)"/&gt;</code>, line 28).</para>
            <para>The raising function checks for the presence of @th:sID attributes in the input
                that are candidates for raising (<code>&lt;xsl:when
                    test="exists($input//@th:sID)"&gt;</code>, line 14; see the discussion of this
                test in <xref linkend="recursion_challenges"/>). If there aren’t any
                    (<code>&lt;xsl:otherwise&gt;</code>, lines 22–24), the recursion is finished,
                and the function returns the result (<code>&lt;xsl:sequence
                    select="$input"/&gt;</code>, line 23). If there are still <code>@th:sID</code>
                attributes in the text, we create a variable <code>$result</code> (lines 15–19) of
                type document and apply templates inside the newly created document node (line 17).
                After the application of templates is finished, we recur and pass the result into
                another invocation of <code>th:raise()</code> (<code>&lt;xsl:sequence
                    select="th:raise($result)"/></code>, line 20).</para>
            <para>The application of templates within the recursive function begins by applying
                templates to the (newly created) document node in loop mode
                    (<code>&lt;xsl:apply-templates select="$input" mode="loop"/&gt;</code>, line
                17). The matching template (lines 30–32) simply applies templates to its children,
                unlike the template that matches the original document node (in no mode, lines
                27–29), which passes the document into the th:raise() function (line 28), a
                difference in mode that is needed to avoid an endless loop. All other processing is
                the same for both the original document and the interim documents created inside
                    <code>th:raise()</code>, so <code>&lt;xsl:template match="/"
                    mode="loop"&gt;</code> (lines 30–32) is the only modal template, and it applies
                templates to its children in no mode.</para>
            <para>There are three templates that do the actual processing of the innermost elements
                to be raised on each recursion: one that processes the start-tag, one that processes
                the content of the newly raised element, and one that processes the corresponding end-tag:<itemizedlist>
                    <listitem>
                        <para><emphasis role="bold">start-tag:</emphasis> We match elements with an
                            @th:sID attribute that has a value equal to the value of a @th:eID
                            attribute on their first following sibling element that has a @th:eID
                            attribute (line 33). This, then, matches only start-tags that contain
                            nothing but <code>text()</code> nodes and elements that have already
                            been raised (from which attributes in the <code>th:</code> namespacethat
                            were present in the input have been discarded). In other words, it
                            matches only the innermost flattened elements, those that do not contain
                            any other empty flattened elements. We process these hits by creating a
                            container element with the same generic identifier as the start-tag and
                            copying all following-sibling nodes that precede the end-tag that
                            matches the start-tag we’re processing at the moment (lines 35–40). In
                            other words, we copy the content of the newly raised element into
                            it.</para>
                    </listitem>
                    <listitem>
                        <para><emphasis role="bold">nodes inside the new wrapper:</emphasis> We have
                            already copied the content of the newly raised element inside it, which
                            means that we don’t want to process those nodes again, since that would
                            create duplicates. For that reason, we suppress all nodes between the
                            start- and end-tags that we’re processing at the moment by matching them
                            inside an empty <code>&lt;xsl:template&gt;</code> element (lines
                            43–44).</para>
                    </listitem>
                    <listitem>
                        <para><emphasis role="bold">end-tag:</emphasis> Since we create real start-
                            and end-tags when we match the flattened start-tag, we have no more use
                            for the flattened end-tag, so we suppress it by matching it, too, inside
                            an empty <code>&lt;xsl:template&gt;</code> element (line 47).</para>
                    </listitem>
                </itemizedlist></para>
            <para>When the simplified original document is flattened and then raised, as described
                above, the output of the raising operation matches the original input. The preceding
                XSLT does not copy attributes from the Trojan milestones because there aren’t any
                non-Trojan attributes in our simplified example, but where needed, non-Trojan
                attributes can be copied from the Trojan start-tag to the new container by changing
                the element constructor to:</para>
            <figure>
                <programlisting>&lt;xsl:element name="{name()}"&gt;
    &lt;xsl:copy-of select="@* except @th:*"/&gt;
    &lt;xsl:copy-of
        select="following-sibling::node()[following-sibling::*[@th:eID eq current()/@th:sID]]"
    /&gt;
&lt;/xsl:element&gt;</programlisting>
                <caption>
                    <para>Element constructor modified to copy non-Trojan attributes to raised
                        elements</para>
                </caption>
            </figure>
        </section>
        <section>
            <title>Raising <emphasis role="ital">Frankenstein</emphasis></title>
            <para>The Trojan markup in the <emphasis role="ital">Frankenstein</emphasis> data
                differs from that of our simplified test sample. Specifically, Trojan start-tags in
                    <emphasis role="ital">Frankenstein</emphasis> have an <code>@ana</code>
                attribute with the value <code>start</code>, end-tags have an <code>@ana</code>
                attribute with the value <code>end</code>, and start- and end-tags are paired by
                sharing a unique value of a <code>@loc</code> attribute. The output requirements are
                to remove the <code>@ana</code> attribute and refactor the <code>@loc</code>
                attribute as an <code>@xml:id</code> attribute. We do that with:</para>
            <figure>
                <programlisting>&lt;xsl:element name="{name()}"&gt;
    &lt;xsl:attribute name="xml:id" select="@loc"/&gt;
    &lt;xsl:copy-of
        select="following-sibling::node()[following-sibling::*[@loc eq current()/@loc]]"/&gt;
&lt;/xsl:element&gt;</programlisting>
                <caption>
                    <para>Element constructor to refactor <code>@loc</code> as <code>@xml:id</code>
                        <emphasis role="ital">Frankenstein</emphasis></para>
                </caption>
            </figure>
            <para>We match Trojan start-tags, (raised) element content, and end-tags in <emphasis
                    role="ital">Frankenstein</emphasis> with the following XPath patterns:</para>
            <figure>
                <programlisting>&lt;xsl:template match="*[@ana eq 'start'][@loc eq following-sibling::*[@ana eq 'end'][1]/@loc]"&gt;</programlisting>
                <caption>
                    <para>XPath expression to match Trojan start-tags in <emphasis role="ital"
                            >Frankenstein</emphasis></para>
                </caption>
            </figure>
            <figure>
                <programlisting>&lt;xsl:template match="node()[preceding-sibling::*[@ana eq 'start'][1]/@loc eq following-sibling::*[@ana eq 'end'][1]/@loc]"/&gt;</programlisting>
                <caption>
                    <para>XPath expression to match the content of raised elements in <emphasis
                            role="ital">Frankenstein</emphasis></para>
                </caption>
            </figure>
            <figure>
                <programlisting>&lt;xsl:template match="*[@ana eq 'end'][@loc eq preceding-sibling::*[@ana eq 'start'][1]/@loc]"/&gt;</programlisting>
                <caption>
                    <para>XPath expression to match Trojan end-tags in <emphasis role="ital"
                            >Frankenstein</emphasis></para>
                </caption>
            </figure>
        </section>
        <section>
            <title>XSLT 1.0</title>
            <para>TODO: rewrite using a recursive named-template call for 1.0 with result element
                extension</para>
        </section>
    </section>

    <section>
        <title>An XSLT 3.0 solution using accumulators (TODO: Michael)</title>
        <para>[To be written. I am assuming that we can find a way to use accumulators to handle
            this.]</para>
    </section>
    <section>
        <title>Global search and replace using regular expressions</title>
        <para>It is not possible to parse arbitrary XML with regular expressions (regex), but it is
            not difficult to identify and process Trojan milestones.<footnote>
                <para>In terms of the Chomsky hierarchy, XML is a Type 2 (context-free) grammar and
                    regular expressions are a Type 3 (regular) grammar. Parsing a context-free
                    grammar, which permits recursion, requires a stack, which is not available in
                    regular grammars. While some modern regular expression implementations support
                    back-referencing and recursion and thus go beyond the limitations of a Chomsky
                    regular grammar, whether methods that rely on these extensions should be
                    considered regular-expression parsing is unclear (this is a theoretical issue),
                    as is the role of legibility in evaluating the suitability of the method to the
                    task (this is a practical concern).</para>
            </footnote></para>
        <para>The following regex matches Trojan start-tags:</para>
        <figure>
            <programlisting>(&lt;[^&gt;]+?)th:sID\s*?=\s*['"]\w+?['"](.*?)\/(&gt;)</programlisting>
            <caption>
                <para>Regex to match Trojan start-tags</para>
            </caption>
        </figure>
        <para>The regex works as follows (in <emphasis role="ital">dot-all</emphasis> mode, that is,
            where dot also matches <code>\n</code>):<itemizedlist>
                <listitem>
                    <para>The first capture group matches everything from the beginning of a tag
                        that contains a <code>@th:sID</code> attribute until that attribute name.
                        This necessarily includes the space that precedes the attribute name, as
                        well as any attributes that might also precede it.</para>
                </listitem>
                <listitem>
                    <para>We do not capture any part of the <code>th:sID</code> attribute: the
                        attribute name, the equal sign (with optional whitespace before or after),
                        the quotation mark value delimiter (single or double), the attribute value
                        (all characters up to the closing value delimiter), and the closing value
                        delimiter. As long as the <code>th:sID</code> and <code>th:eID</code> values
                        are created with the XPath <code>generate-id()</code> function, they cannot
                        contain single or double quotation marks (<code>generate-id()</code> creates
                        only values that are XML names), so we do not need to verify that the
                        opening and closing delimiters match each other lexically.<footnote>
                            <para>“The returned identifier must consist of ASCII alphanumeric
                                characters and must start with an alphabetic character. Thus, the
                                string is syntactically an XML name.” [<xref linkend="xpath"/>,
                                    <link
                                    xlink:href="https://www.w3.org/TR/xpath-functions-31/#func-generate-id"
                                    >§14.5.4</link>]</para>
                        </footnote></para>
                </listitem>
                <listitem>
                    <para>The second capture group captures everything following the
                            <code>@th:sID</code> attribute up to the <code>/&gt;</code> that marks
                        the end of the tag.</para>
                </listitem>
                <listitem>
                    <para>We do not capture the <code>/</code> before the closing <code>&gt;</code>.<footnote>
                            <para>Forward slash has to be escaped in some regex implementations, but
                                not in others. Escaping where it is not required does no
                                harm.</para>
                        </footnote></para>
                </listitem>
                <listitem>
                    <para>The third capture group captures the closing <code>&gt;</code>.</para>
                </listitem>
            </itemizedlist></para>
        <para>We replace all matches with the following replacement pattern:</para>
        <figure>
            <programlisting>\1\2\3</programlisting>
            <caption>
                <para>Replacement pattern for Trojan start-tags</para>
            </caption>
        </figure>
        <para>The regex to match Trojan end-tags is similar to the one for start-tags, and because
            real end-tags cannot contain attributes, we do not need to match or copy them. We
            capture the opening <code>&lt;</code> separately from whatever follows it, so that we
            can write a <code>/</code> into the replacement after it. The regex is:</para>
        <figure>
            <programlisting>(&lt;)(\S+?)\s+[^&gt;]*?th:eID=['"]\w+['"][^&gt;]*?\/(&gt;)</programlisting>
            <caption>
                <para>Regex to match Trojan end-tags</para>
            </caption>
        </figure>
        <para>and the replacement pattern is:</para>
        <figure>
            <programlisting>\1/\2\3</programlisting>
            <caption>
                <para>Replacement pattern for Trojan end-tags</para>
            </caption>
        </figure>
        <para>This method will incorrectly apply the replacement to matching patterns within XML
            comments and CDATA marked sections. With insincere apologies for disappointing Regex
            Edge-Case Bounty Hunters, coping with matches in these contexts, which would not
            naturally appear in our data, is not a goal in our work.<footnote>
                <para>Similarly, we rely on the use of <code>th:</code> as the namespace prefix and
                        <code>th:sID</code> and <code>th:eID</code> as the attribute names for our
                    Trojan attributes. Changing these assumptions is not a problem as long as the
                    regex is changed to match.</para>
            </footnote></para>
        <para>A more serious limitation of this method is that because it is not XML-aware, it can
            be used only in situations where raising is guaranteed not to create overlap. For
            example, given input like:</para>
        <figure>
            <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;root xmlns:th="http://www.blackmesatech.com/2017/nss/trojan-horse"&gt;
    &lt;page th:sID="page1"/&gt;
    &lt;para th:sID="para1"/&gt;Content on page 1 in paragraph 1 
    &lt;page th:eID="page1"/&gt;
    &lt;page th:sID="page2"/&gt;Content on page 2 in para 1 
    &lt;para th:eID="para1"/&gt;
    &lt;para th:sID="para2"/&gt;Content on page 2 in para 2
    &lt;para th:eID="para2"/&gt;
    &lt;page th:eID="page2"/&gt;
&lt;/root&gt;</programlisting>
            <caption>
                <para>XML that cannot be unflattened without creating overlap</para>
            </caption>
        </figure>
        <para>the result of converting all Trojan milestones to real start- and end-tags would
            be:</para>
        <figure>
            <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;root&gt;
    &lt;page&gt;
        &lt;para&gt;Content on page 1 in paragraph 1 
    &lt;/page&gt;
    &lt;page&gt;Content on page 2 in para 1 
        &lt;/para&gt;
        &lt;para&gt;Content on page 2 in para 2&lt;/para&gt;
    &lt;/page&gt;
&lt;/root&gt;</programlisting>
            <caption>
                <para>Invalid (overlapping) result of converting all Trojan milestones to real start
                    and end tags</para>
            </caption>
        </figure>

        <para>The resulting document is not well-formed because the pages and paragraphs overlap. It
            is, however, possible to raise just pages but not paragraphs, or just paragraphs but not
            pages, without creating overlap, and the result would be well-formed.</para>
        <para>[In order to time this, we will want to perform these tasks with sed, emacs in batch
            mode, and/or Perl or Python.]</para>
    </section>
    <section>
        <title>Pull parsing in Python</title>
        <para>The Python <code>xml.dom.pulldom</code> module that can be used to stream an XML
            document past an event handler that can be instructed to raise a flattened hierarchy.<footnote>
                <para>The authors are grateful to Ronald Haentjens Dekker for bringing this method
                    to our attention. The example at his
                        <link>https://github.com/rhdekker/python_xml_pull_parser_example</link>
                    GitHub repository is a partial model for the examples here.</para>
            </footnote> The result of pull parsering can be fashioned into output in two ways, as a
            string or as XML. With string output, this method is comparable to the regex replacement
            strategy described above: it passes all events through unchanged except for Trojan
            milestones, which it replaces with regular XML start- and end-tags. Because the output
            construction is not XML-aware, it has the same limitations as the regex approach: most
            significantly, it is capable of creating output that includes overlap, and that
            therefore is not well formed XML. With XML output, though, we use
                <code>xml.dom.minidom</code> to create XML elements within a DOM structure, and the
            result is necessarily well-formed. Pull parsing operates as a single depth-first
            traversal, which is to say that it begins at the document node and touches each element
            only once. With string output, the procedure can create write output as it handles each
            event; with XML output, it is necessary to maintain the current context in a
            stack.</para>
        <section>
            <title>String output</title>
            <para>The following Python 3 code replaces Trojan milestones with strings equivalent to
                real XML start- and end-tags:</para>
            <figure>
                <programlisting>from xml.dom.pulldom import CHARACTERS, START_ELEMENT, parseString, END_ELEMENT

output = []
with open('flattened.xml') as input:
    for event, node in parseString(input.read()):
        if event == START_ELEMENT:
            if node.hasAttribute('th:eID'):
                output.append('&lt;/')
            else: # Trojan start tags and non-Trojan
                output.append('&lt;')
            output.append(node.nodeName)
            for attname, attvalue in node.attributes.items():
                if not(attname.startswith('th:')):
                    output.append(' ' + attname + '="' + attvalue + '"')
            output.append('>')
        if event == END_ELEMENT:
            if not node.hasAttribute('th:sID') and not node.hasAttribute('th:eID'):
                output.append('&lt;/' + node.localName + '>')
        elif event == CHARACTERS:
            output.append(node.data)
print("".join(output))</programlisting>
                <caption>
                    <para>Python code that constructs the XML output as a string</para>
                </caption>
            </figure>
            <para>We create an empty list to hold the output, read in the source, and examine each
                event. In this simplified example, we process only <code>START_ELEMENT</code>,
                    <code>END_ELEMENT</code>, and <code>CHARACTERS</code>, as follows:</para>
            <itemizedlist>
                <listitem>
                    <para><code>START_ELEMENT.</code> Trojan milestones with <code>@th:eID</code>
                        attributes are flattened end-tags, so when we encounter one, we output
                            <code>&lt;/</code>; for other <code>START_ELEMENT</code> events we
                        output only <code>&lt;</code>. We follow this with the gi
                            (<code>node.nodeName</code>) and then iterate over the attributes. For
                        each non-Trojan attribute, we output a space, the attribute name, an equal
                        sign, and the attribute value in quotation marks. Finally, we output the
                        closing <code>&gt;</code>.</para>
                </listitem>
                <listitem>
                    <para><code>END_ELEMENT.</code> Although Trojan milestones are single tags, they
                        fire both <code>START_ELEMENT</code> and <code>END_ELEMENT</code> events.
                        Since we process all Trojan milestones at their <code>START_ELEMENT</code>
                        events, we ignore their <code>END_ELEMENT</code> events. For other
                            <code>END_ELEMENT</code> events, we create a regular end-tag.</para>
                </listitem>
                <listitem>
                    <para><code>CHARACTERS.</code> We add character data content to the
                        output.</para>
                </listitem>
            </itemizedlist>
            <para>We are parsing the input XML in an XML-aware manner, which is reasonably robust,
                but we are constructing the output XML as a string, which is not. See below for a
                discussion of the limitations.</para>
            <para>[TODO: namespace-aware, instead of string-matching on attribute names?]</para>
        </section>
    </section>
    <section>
        <title>Some things that can go wrong</title>
        <para>Each of the methods described above comes with its own complications. Some of these
            are challenges that can be overcome, others are limitations in what the method can
            manage, and others are deal-breakers that show that the method is not ultimately
            suitable for realistic use cases. In this section we review briefly the complications
            for each method.</para>
        <section>
            <title>EBB’s implementation of right-sibling recursion (TODO: Elise)</title>
            <para>EBB’s implementation of right-sibling recursion, with analysis and
                discussion.</para>
        </section>
        <section>
            <title>Right-sibling traversal (TODO: Michael)</title>
            <para>MSM’s bugs include a failure to specify the correct mode on an apply-templates
                call, which meant that processing slipped out of the special mode and into default
                mode, and many nodes appeared repeatedly in the input: tenfold increase in size of
                document, and more.</para>
        </section>
        <section xml:id="recursion_challenges" xreflabel="Inside-out recursion challenges">
            <title>Inside-out recursion</title>
            <para>The two principal pitfalls with inside-recursion are <emphasis role="ital">double
                    processing</emphasis> and <emphasis role="ital">endless
                recursion</emphasis>.</para>
            <section>
                <title>Double processing</title>
                <para>When a start-tag is matched and raised, the nodes that belong inside it are
                    copied into it inside the template that matches the start-tag. Because the nodes
                    being copied are also candidates for the application of templates in the current
                    pass through the function, we need to match them (along with the end-tag) in an
                    empty <code>&lt;xsl:template&gt;</code> in order to avoid outputting them twice.
                    Otherwise they would be copied when the start-tag is matched and then processed
                    again when templates are applied to them in their own right.</para>
            </section>
            <section>
                <title>Endless recursion</title>
                <para>Recursion requires an exit condition to avoid falling into an endless loop. In
                    an early version of the code, the recursive function tested for the presence of
                    Trojan milestone attributes, and if there weren’t any, it concluded that all
                    raising had been completed and stopped the recursion. This test fails in
                    situations where there are Trojan elements that cannot be raised without
                    creating overlap. Avoiding the endless loop in such situations requires a more
                    complex test, not just for the presence of Trojan attributes, but for the
                    presence of those that can be raised without creating overlap. In our simplified
                    sample, instead of testing for <code>exists($input//@th:sID)</code>, we test for
                    elements that can be raised without risk of overlap with:</para>
                <figure>
                    <programlisting>exists($input//*[@th:sID eq following-sibling::*[@th:eID][1]/@th:eID])</programlisting>
                    <caption>
                        <para>Test for Trojan milestones that can be raised without creating
                            overlap</para>
                    </caption>
                </figure>
                <para>Endless recursion is not an issue in situations where complete raising would
                    not create overlap. This is the case with our original simplified sample, where
                    the XML with Trojan markup was created by flattening original hierarchical XML,
                    and since the original could not have had overlap, it can be reconstructed
                    safely. Endless recursion is also not a problem when we raise only a subset of
                    the markup that is guaranteed not to overlap. For example, if we have
                    tessellated page and paragraph hierarchies over a prose text, where both pages
                    and paragraphs have been flattened, we cannot fully raise all instances both
                    types of elements if doing so would create overlap. But if our markup convension
                    is that pages cannot overlap with pages and paragraphs cannot overlap with
                    paragraphs, we can modify the raising routine to raise only the pages or only
                    the paragraphs. See also <xref linkend="tessellated"/>, where we discuss an
                    alternative approach to raising with data of this type.</para>
            </section>
        </section>
        <section>
            <title>Accumulators (TODO: Michael)</title>
            <para>MSM's single combat with accumulators</para>
        </section>
        <section>
            <title>Regex</title>
            <para>The only challenge to writing the regex (aside from the risk of inadvertently
                creating XML that is not well-formed because of overlap, which is discussed above)
                is anticipating variation in the markup. For example, an XML start-tag with a single
                attribute looks like <code>&lt;gi attname="value"&gt;</code>, but it allows optional
                whitespace around the equal sign and before the closing <code>&gt;</code>
                delimiter—but not between the opening <code>&lt;</code> delimiter and the generic
                identifier, and not between the <code>/</code> and the <code>&gt;</code> at the end
                of a self-closing empty tag. Where it allows whitespace, it allows any amount of any
                combination of whitespace characters.</para>
            <para>Within the context of a single project, the easiest way to deal with the allowable
                variation is not to allow it, that is, to enforce rigorous consistency even where
                XML syntax does not require it. But because rigorous consistency is difficult to
                achieve without computational validation, we opted for a more robust regex—that is,
                one more accepting of variation, even though allowing for variation made the regex
                harder to read and develop.</para>
        </section>
        <section>
            <title>Python pull parsing (TODO: David)</title>
            <para>The Python pull parser reads the input XML as XML and responds to parse events. We
                handle <code>START_ELEMENT</code>, <code>END_ELEMENT</code>, and
                    <code>CHARACTERS</code>, and ignore other events, and we use XML-aware methods
                to access attributes. With respect to managing the input, then, this is a reasonably
                robust strategy. The quality of the output handling depends on whether we create
                output as a string or as an XML DOM.</para>
            <section>
                <title>String output</title>
                <para>Creating XML output as a string is a brittle strategy. Not only is it
                    susceptible to writing overlapping tags for the same reason as the regex method
                    described earlier, but we also explicitly wrap attribute values in double-quote
                    characters (<code>"</code>). This will produce results that are not well-formed
                    if the attribute value happens to have contained the double-quote character
                    originally. Python has an escape mechanism that is capable of dealing with
                    awkwardly nested single- and double-quote characters in strings, as does XML,
                    but the Python escape strategy is different from the XML one, and the code to
                    perform the string manipulation needed to mediate between the two is difficult
                    to read and write. For that reason, it is safer to use XML methods to create the
                    XML output as a (necessarily well-formed) DOM tree, which can then be
                    serialized, instead of creating the output directly as a string.</para>
            </section>
        </section>
    </section>
    <section>
        <title>Comparison (David, with input from Michael and Elisa in subsections)</title>
        <para>The inside-out recursive approach (both the function-based XSLT 3.0 version and
            named-template-based XSLT 1.0 one) is tail-recursive, which means that an XSLT processor
            that performs tail-call optimization will not be at risk for running out of stack space.
            In cases where tail-call optimization is not available, the maximum depth of recursion
            is equal to the <emphasis role="ital">depth</emphasis> of the deepest Trojan element in
            the input hierarchy. The right-sibling traversal approach (both the XSLT 3.0 and the
            XSLT 1.0 versions) is also tail-recursive (TODO: Michael, is this correct?), and with an
            XSLT parser that does not perform tail-call optimization, it requires stack space equal
            to the maximum <emphasis role="ital">width</emphasis> of the widest hierarchical
            level.</para>
        <para>Insofar as an open-source XSLT 3.0 processor that performs tail-call optimization is
            freely available in the open-source, platform-independent Saxon-HE product [<xref
                linkend="saxon"/>], the difference in stack requirements between the two methods has
            not been a consideration for our purposes. But insofar as XML documents of the sort that
            are of interest to digital humanists are typically wider than they are deep, users who
            are unable to employ an XSLT processor that performs tail-call optimization may favor
            inside-out processing over right-sibling traversal because inside-out processing is
            likely to require less stack space.</para>
        <para>(TODO: Michael: I find the inside-out approach simpler, that is, easier to understand,
            but I don’t know whether that’s because it is simpler, or because of the greater
            familiarity that comes with having developed it. If it is objectively simpler, should we
            mention that in our comparison?)</para>
        <para>TODO: Unassigned: [Measurement of time and space complexity running all solutions on
            the same data (as large as we can manage—e.g., all of <emphasis role="ital"
                >Frankenstein</emphasis>, or an artificial document containing 10 or 100 copies of
                <emphasis role="ital">Frankenstein</emphasis>).]</para>
        <para>TODO: Unassigned: [Time complexity is easy enough to measure; space complexity may be
            harder, but we may be able to find ways. I believe that the Unix tool <emphasis
                role="bold">top</emphasis> gives the current memory usage of a task, so the
            information is certainly available.]</para>
        <para>TODO Unassigned: [One reason I would like to have multiple XSLT 1.0 solutions is so
            that we can test performance in more than one implementation: <emphasis role="bold"
                >xsltproc</emphasis>, <emphasis role="bold">Xalan</emphasis>, and browser XSLT
            engines, if we can figure out how to persuade a browser to do the work.</para>
        <para>TODO Unassigned: [My prediction a priori is that using <emphasis role="bold"
                >sed</emphasis>, <emphasis role="bold">emacs</emphasis>, <emphasis role="bold"
                >perl</emphasis>, or <emphasis role="bold">Python</emphasis> to make the changes
            with regular expressions will be much faster than using XSLT. Without XSLT, it will be
            much easier to produce output that’s not well-formed; it would be good to document how
            many attempts are needed before our sed script is producing well-formed output, and how
            many more are needed before it’s both well formed and correct. djb: I spent about an
            hour crafting and debugging the regex expressions for the start and end tags. It
            produces well-formed output with my baby sample, recreating the original document
            (before flattening) faithfully. I look forward to the Frankentest!]</para>
    </section>
    <section>
        <title>Conclusion (TODO: Unassigned)</title>
        <para>[what do we say here? djb: The conclusion of my micro-pipelining paper last year may
            be applicable here, too. It reads: “None of the methods described here is new, but their
            explicit juxtaposition, comparison, and evaluation in a tutorial context based on real
            use cases has clarified much about micropipelining for the author, and, it is hoped, for
            the reader, as well.”]</para>
    </section>
    <appendix xml:id="tessellated">
        <title>Raising tessellated hierarchies (TODO: djb)</title>
        <para>Raising tessellated hierarchies is a common requirement for hierarchy <emphasis
                role="ital">inversion</emphasis>.<footnote>
                <para><emphasis role="ital">Tessellated</emphasis> structures cover an entire domain
                    with the same pattern without gaps or self-overlap, much as mosaic tiles might
                    cover an entire floor.</para>
            </footnote> Consider a simple print document that can be understood as containing a
            sequence of pages or a sequence of paragraphs, where each sequence fully covers the
            content without self-overlap, but where the two different element types overlap in a way
            that makes it impossible to use container elements for both. One typical XML workflow
            with such structures involves encoding one hierarchy with XML container elements and the
            other with milestones. For example, a TEI novel transcribed from an original source
            might be structured with <code>&lt;div&gt;</code> elements for chapters, which contain
                <code>&lt;head&gt;</code> elements for chapter titles and <code>&lt;p&gt;</code>
            elements for paragraphs, with page beginnings encoded as empty <code>&lt;pb/&gt;</code>
            elements. If is later becomes necessary to operate on the pages as units, we can
                <emphasis role="ital">invert</emphasis> the markup by transforming the
            page-beginning milestones into page container elements, while flattening the elements
            that demarcate chapters, titles, and paragraphs.</para>
        <para>The method described in this appendix differs from those described above because it
            works only where the hierarchy being raised is tessellated. That outcome requirement
            invites the use of <code>&lt;xsl:for-each-group&gt;</code>, which partitions its entire
            domain exhaustively into groups. The same property that makes
                <code>&lt;xsl:for-each-group&gt;</code> suitable for a situation where an entire
            text may be partitioned into tessellated paragraphs or tessellated pages makes it a poor
            choice for the contexts described in the body of this report, where new container
            elements must be created only around small islands of content.</para>
        <para>[TODO: DJB use case from <link>http://suprasliensis.obdurodon.org</link>]</para>
    </appendix>
    <bibliography>
        <title>Works cited</title>
        <bibliomixed xml:id="collatex" xreflabel="CollateX"><emphasis role="ital">CollateX: software
                for collating textual sources.</emphasis>
            <link>https://collatex.net/-</link></bibliomixed>
        <bibliomixed xml:id="derose_2004" xreflabel="DeRose 2004">DeRose, Steve. 2004. “Markup
            Overlap: a review and a horse.” Presented at Extreme Markup Languages 2004. Montréal,
            Québec, August 2-6, 2004.
            <link>http://xml.coverpages.org/DeRoseEML2004.pdf</link></bibliomixed>
        <bibliomixed xml:id="tei_p5" xreflabel="TEI P5">P5: <emphasis role="ital">Guidelines for
                electronic text encoding and interchange.</emphasis>
            <link>http://www.tei-c.org/guidelines/P5/</link></bibliomixed>
        <bibliomixed xml:id="frankenstein" xreflabel="Variorum Frankenstein">Frankenstein <emphasis
                role="ital">Variorum Project.</emphasis>
            <link>https://github.com/PghFrankenstein/Pittsburgh_Frankenstein</link></bibliomixed>
        <bibliomixed xml:id="saxon" xreflabel="Saxon-HE">Saxon-HE (home edition).
                <link>http://saxon.sourceforge.net/</link></bibliomixed>
        <bibliomixed xml:id="xpath" xreflabel="XPath functions"><emphasis role="ital">XPath and
                XQuery functions and operators 3.1 W3C recommendation 21 March 2017.</emphasis>
            <link>https://www.w3.org/TR/xpath-functions-31/</link></bibliomixed>
    </bibliography>
</article>
