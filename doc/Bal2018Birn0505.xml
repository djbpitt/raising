<?xml version="1.0" encoding="UTF-8"?>
<?xml-model href="balisage/balisage-1-3.rng" type="application/xml" schematypens="http://relaxng.org/ns/structure/1.0"?>
<?xml-stylesheet type="text/xsl" href="local.xsl"?>
<!DOCTYPE article [
<!--* zero-width space:  used in print versions of
URIs to allow line breaks *-->
<!ENTITY ZWSP "&#x200B;">
]>
<article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
    <title>Flattening and unflattening XML markup:
    a Zen garden of XSLT and other tools</title>
    <info>
        <abstract>
            <para>From time to time, it may be necessary or expedient
            to flatten our XML documents by replacing the start- and
            end-tags of conventional XML content elements with empty
            place-marker elements (variously known as <emphasis
            role="ital">milestone elements</emphasis> or as
            <emphasis>Trojan horse markup</emphasis>). When we do, we
            will often wish, later, to restore the content elements we
            flattened. The purpose of this late-breaking presentation
            is to present a survey of ways to perform the task of
            unflattening or of raising: restoring a conventional XML
            element structure of content elements from a flattened XML
            document instance (or part of one), and comparing
            different solutions to see what we can learn from
            them.</para>
        </abstract>
        <author>
            <personname>
                <firstname>David</firstname>
                <othername>J.</othername>
                <surname>Birnbaum</surname>
            </personname>
            <personblurb>
                <para>David J. Birnbaum is Professor and Co-Chair of
                the Department of Slavic Languages and Literatures at
                the University of Pittsburgh. He has been involved in
                the study of electronic text technology since the
                mid-1980s, has delivered presentations at a variety of
                electronic text technology conferences, and has served
                on the board of the Association for Computers and the
                Humanities, the editorial board of <emphasis
                role="ital">Markup languages: theory and
                practice</emphasis>, and the Text Encoding Initiative
                Council. Much of his electronic text work intersects
                with his research in medieval Slavic manuscript
                studies, but he also often writes about issues in the
                philosophy of markup.</para>
            </personblurb>
            <affiliation>
                <jobtitle>Professor of Slavic Languages and Literatures</jobtitle>
                <orgname>University of Pittsburgh, Pittsburgh, PA</orgname>
            </affiliation>
            <email>djbpitt@gmail.com</email>
        </author>
        <author>
            <personname>
                <firstname>Elisa</firstname>
                <othername>E.</othername>
                <surname>Beshero-Bondar</surname>
            </personname>
            <personblurb>
                <para>Elisa Beshero-Bondar is a member of the TEI
                Technical Council, as well as an Associate Professor
                of English and Director of the Center for the Digital
                Text at the University of Pittsburgh at
                Greensburg. Her projects investigate complex texts
                such as epics, plays, and multi-volume voyage logs,
                and involve her in experimentations with the TEI,
                including refining methods for computer-assisted
                collation of editions and probing questions of
                interoperability to reconcile diplomatic and critical
                edition encodings. She is the founder and organizer of
                the <link
                xlink:href="http://digitalmitford.org">Digital Mitford
                project</link> and its annual coding school.</para>
            </personblurb>
            <affiliation>
                <jobtitle>Associate Professor of English</jobtitle>
                <jobtitle>Director, <link
                        xlink:href="http://www.greensburg.pitt.edu/digital-humanities/center-digital-text"
                        >Center for the Digital Text</link></jobtitle>
                <orgname>University of Pittsburgh at Greensburg</orgname>
            </affiliation>
            <email>ebb8@pitt.edu</email>
        </author>
        <author>
            <personname>
                <firstname>C.</firstname>
                <othername>M.</othername>
                <surname>Sperberg-McQueen</surname>
            </personname>
            <personblurb>
                <para>C. M. Sperberg-McQueen is the founder and
                principal of <link
                xlink:href="http://www.blackmesatech.com/">Black Mesa
                Technologies</link>, a consultancy specializing in
                helping memory institutions improve the long term
                preservation of and access to the information for
                which they are responsible. He served as editor in
                chief of the TEI Guidelines from 1988 to 2000, and has
                also served as co-editor of the World Wide Web
                Consortium’s XML 1.0 and XML Schema 1.1
                specifications.</para>
            </personblurb>
            <affiliation>
                <jobtitle>Founder and Principal</jobtitle>
                <orgname>Black Mesa Technologies</orgname>
            </affiliation>
            <email>cmsmcq@blackmesatech.com</email>
        </author>
    </info>
    
    <section>
        <title>Overview</title>
        
        <para>From time to time, it may be necessary or expedient to
        flatten our XML documents by replacing the start- and end-tags
        of conventional XML content elements with empty place-marker
        elements. These place-markers are variously known as
        <emphasis role="ital" >milestone elements</emphasis> after
        the milestone technique described in the TEI Guidelines for
        page beginnings, column beginnings, line beginnings,
        etc. [<xref linkend="tei_p5"/>], or <emphasis>Trojan horse
        markup</emphasis> after the technique described by Steve
        DeRose [<xref linkend="derose_2004"/>]. To avoid
        over-stressing any particular syntax, we will
        use a more general term, <emphasis>markers</emphasis>. When we do flatten
        our documents, we will often wish, later, to convert markers back into their original form as
        content elements. The three co-authors discovered
        recently that we had each had occasion to perform this task,
        and that we had undertaken it using different
        techniques.<footnote>
        
            <para>Community interest in flat-to-hierarchy and
            hierarchy-to-flat transformations is confirmed by their
            inclusion in Abel Braaksma’s 2014 proposal, on the XSLT
            mailing list, that they be included among the top 10 most
            used XSLT design patterns. See
            <link
                xlink:href=
                "https://www.biglist.com/lists/lists.mulberrytech.com/xsl-list/archives/201404/msg00028.html"
                >https://www.biglist.com&ZWSP;/lists&ZWSP;/lists.mulberrytech.com&ZWSP;/xsl-list&ZWSP;/archives&ZWSP;/201404&ZWSP;/msg00028.html</link>.</para>
            <!--* Do we think that this is what he had in mind?
                * I would have thought he meant eliminating divs
                * from HTML, and introducing divs to match the
                * heading levels.  But I'm happy to leave it, and we
                * can ask him in August.
                *-->
        </footnote>
        </para>
        
        <para>The purpose of this late-breaking presentation is to
        survey multiple ways to perform the task of unflattening or
        raising, that is, restoring a conventional XML element
        structure of content elements from a flattened XML document
        instance.  We will compare different
        solutions to see what we can learn from them. Nothing here is
        profoundly difficult or new, but each of us found it
        challenging and interesting enough that we think it may be
        worth while to share what we have learned with others.</para>

        <para>In the following sections, we describe first a concrete
        instance of the task, with enough supporting detail to make
        clear that this is not an academic exercise but one that
        arose in a real project. We then present several
        approaches to solving the problem, including some false
        starts, which illustrate possible wrong turnings along the
        way. We then discuss and compare the different solutions with
        respect to coding difficulty and costs in space and
        time.</para>
        

        <para>In the discussions that follow, we adopt the following
        terminology in an attempt to avoid unnecessary
        confusion. First, we distinguish content elements (marked by
        standard XML start- and end-tags) from virtual elements
        (indicated by markers).<variablelist>
        
            <varlistentry>
                <term>content element</term>
                <listitem>
                    <para>a conventional XML element marked by start- and end-tags with
                    (possibly empty) content between them, or by a sole-tag. Cf. <emphasis
                    role="ital">marker</emphasis>.</para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>virtual element</term>
                <listitem>
                    <para>a <quote>logical</quote> element indicated by start- and
                    end-markers.</para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>marker</term>
                <listitem>
                    <para>an empty XML element serving to mark the start or end of a virtual
                    element.</para>
                </listitem>
            </varlistentry>
            
        </variablelist>
        </para>
        
        <para>We are interested in two processes that convert between content elements and virtual
            elements indicated by markers: <variablelist>
                <varlistentry>
                    <term>flattening</term>
                    <listitem>
                        <para>the process of replacing the start- and end-tags of content
                            elements with corresponding start- and end-markers.</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>raising (aka <emphasis>unflattening</emphasis>)</term>
                    <listitem>
                        <para>the process of replacing virtual elements with content elements by converting pairs of start- and end-markers into corresponding start- and end-tags.</para>
                    </listitem>
                </varlistentry>
        </variablelist></para>
        
        <para>Our approaches for raising flattened XML may be categorized according to the following parameters:<itemizedlist>
                <listitem>
                    <para>Whether they read their input as XML or as a string.</para>
                </listitem>
                <listitem>
                    <para>Whether they construct their output as XML or as a string.</para>
                </listitem>
                <listitem>
                    <para>For those that read the input as XML, the
                    order in which they raise the virtual elements.</para>
                </listitem>
        </itemizedlist></para>
        
        <para> The methods that work with the input and output as XML
        are typically recursive (whether the recursion is implemented
        through functions or templates), and the recursion follows one
        of three patterns:<itemizedlist>
        <listitem> 
                    <para>The input is handled in a single pass and
                    the virtual elements are raised <emphasis>left-to-right</emphasis> in
                    start-tag/end-tag order.</para>
                    <para>We refer to the order as <emphasis>left-to-right</emphasis> or tag-order,
                        rather than as depth-first, partly because in the input the markers and the
                        content of the virtual elements they mark are all siblings. That is, the
                        input document is typically a shallow hierarchy and there is no difference
                        between depth- and breadth-first traversal of the input tree. With respect
                        to the output tree, this pattern performs a <emphasis>depth-first pre- and
                            post-order traversal</emphasis>: that is, the processing of an element
                        starts before the processing of its children and ends afterwards. </para>
                    <para>We refer to the construction as <emphasis>tag-order</emphasis>
                    because the construction of the virtual elements
                    begins in the order of their start-markers and
                    ends in the order of their end-markers.</para>
                </listitem>
                <listitem>
                    <para>The input is processed in multiple passes;
                    on each pass the innermost or bottom-most virtual
                    element(s) are raised to become content
                    elements.</para>
                    <para>We refer to the construction as <emphasis>bottom-up</emphasis>
                    because in each parent-child pair of the output,
                    the construction of the child begins and ends
                    before the construction of the parent
                    begins.</para>
                    <para>As in the preceding case, because the input
                    has no meaningful depth, it is more appropriate to
                    describe the traversal without using hierarchical
                    terms, although <emphasis>bottom-up</emphasis> is an appropriate way to
                    refer to the order in which nodes of the final
                    output tree are completed.</para>
                </listitem>
                <listitem>
                    <para>The input is processed with a series of
                    recursive calls to a function or template to
                    operate on a sequence of nodes.  On each call, the
                    left-most start-marker in the sequence and its
                    matching end-marker are selected.  Material which
                    precedes the selected start-marker is returned
                    without change; material between the selected
                    markers is processed recursively as the content of
                    a newly raised element; material which follows the
                    selected end-marker is processed recursively as
                    the following siblings of the newly raised
                    element.<footnote>
                    <para>Ideally, all the outermost elements in the
                    input sequence would be recognized and processed
                    in a single call to the function, but we have not
                    found a way to achieve this.</para>
                    </footnote>
                    </para>
                    <para>We refer to the construction as <emphasis>outside-in</emphasis>
                    because on each call (one of) the outermost
                    element(s) in the parameter sequence is raised,
                    and a recursive call operates on elements
                    contained within that one.</para>
                </listitem>
        </itemizedlist></para>
        
        <para>With respect to those parameters, the methods discussed
        below may be classified as follows:</para>

        <!--* 20 July.  MSM decides 'input traversal' is not a useful
            concept here and comments that column out, despite
            consciousness that DJB was trying to distinguish
            systematically between 'input traversal' and 'output
            construction'.
            
            Input traversal makes sense as a concept for programs
            that move around a tree; the sense in which the use
            of apply-templates in XSLT moves around the tree is
            at best a loose one: processors can reorder the templates
            in time however they like.
            
            MSM adds 'Passes', discovers we already have it; moves it.
            
            Suppresses 'recursion' and 'stack' as not intrinsic to
              the method but accidents of implementation            
            Renames 'output construction' and 'well-formed'.        
            *-->
        <table>
          <col width="2"/><!--* method *-->
          <col width="1"/><!--* input *-->
          <col width="1"/><!--* output *-->
          <col width="1"/><!--* order *-->
          <col width="1"/><!--* passes *-->
          <col width="2"/><!--* overlap handling *-->
            <thead>
                <tr>
                    <th>Method</th>
                    <th>Input</th>
                    <th>Output</th>
                    <!--* <th>Input traversal</th> *-->
                    <th>Raising Order</th>
                    <!--* 
                    <th>Recursive?</th>
                    <th>Stack?</th>
                    *-->
                    <th>Passes / Calls</th>
                    <th>Overlap handling</th>
                    <!--* MSM finds "well-formed" an unhappy
                        name for this column, but has not found
                        a better one. *-->
                </tr>
            </thead>
            <tbody>
                <tr>
                    <th>Right-sibling traversal</th>
                    <td>XML</td>
                    <td>XML</td>
                    <!--* <td>Depth first</td> *-->
                    <td>Left to right</td>
                    <!--* <td>Template</td> *-->
                    <!--* <td>No</td> *-->
                    <td>Single</td>
                    <td>Silent error</td>
                </tr>
                <tr>
                    <th>Inside-out recursion</th>
                    <td>XML</td>
                    <td>XML</td>
                    <!--* <td>Inside out</td> *-->
                    <td>Inside-out</td>
                    <!--* <td>Function</td> *-->
                    <!--* <td>No</td> *-->
                    <td>Depth of tree</td>
                    <td>Partial raising, well formed</td>
                    <!--* Actually, at the moment it's producing
                        erroneous output, doubling some text
                        nodes. But we'll pretend we didn't see that,
                        OK? Just our little secret, ours and
                        whoever reads the XML source. *-->
                </tr>
                <tr>
                    <th>Outside-in recursion</th>
                    <td>XML</td>
                    <td>XML</td>
                    <!--* <td>Breadth first</td> *-->
                    <td>Outside-in</td>
                    <!--*
                    <td>Function</td>
                    <td>No</td>
                    *-->
                    <td>Number of virtual elements</td>
                    <!--* NOT <td>Single</td> ! *-->
                    <td>Partial raising, well formed</td>
                </tr>
                <tr>
                    <th>Accumulator</th>
                    <td>XML</td>
                    <td>XML</td>
                    <!--*
                    <td>Pre- and
                        post-traversal </td>  *--><!-- Michael, is this the *traversal method*? -->
                    <td>Left to right</td>
                    <!--* <td>No</td> *-->
                    <!--* <td>Array</td> *-->
                    <td>Single</td>
                    <td>Silent error</td>
                </tr>
                <tr>
                    <th>Regex replacement</th>
                    <td>String</td>
                    <td>String</td>
                    <!--* <td>Left to right</td> *-->
                    <td>Left to right</td>
                    <!--* <td>No</td> *-->
                    <!--* <td>No</td> *-->
                    <td>Single or double</td>
                    <td>Full raising, ill formed</td>
                </tr>
                <tr>
                    <th>Python pull parser 1</th>
                    <td>XML</td>
                    <td>String</td>
                    <!--* <td>Depth first (left to right)</td> *-->
                    <td>Left to right</td>
                    <!--* <td>No</td> *-->
                    <!--* <td>No</td> *-->
                    <td>Single</td>
                    <td>Full raising, ill formed</td>
                </tr>
                <tr>
                    <th>Python pull parser 2</th>
                    <td>XML</td>
                    <td>XML</td>
                    <!--* <td>Depth first (left to right)</td> *-->
                    <td>Left to right</td>
                    <!--* <td>No</td> *-->
                    <!--* <td>List</td> *-->
                    <td>Single</td>
                    <td>Silent error</td>
                </tr>
            </tbody>
        </table>
        
        <itemizedlist>
            <listitem>
                <para>We have implemented the last three methods in
                Python and the others in XSLT (and experimentally in
                XQuery). The accumulator method requires XSLT 3.0; the
                inside-out, and outside-in methods can all be
                implemented with (recursive) function calls in XSLT
                2.0 and 3.0 and with named templates in XSLT 1.0.
                Right-sibling traversal has been implemented using
                match templates; an experimental implementation using
                a recursive function is also contemplated.</para>
            </listitem>
            <listitem>
                <para><emphasis role="ital">Input</emphasis> and <emphasis role="ital"
                >Output</emphasis> refer to whether the input is read as XML or as a string,
                    and whether the output is constructed as a DOM tree or as a string.</para>
            </listitem>
            <!--*
            <listitem>
                <para><emphasis role="ital">Input traversal</emphasis> describes how the method
                    chooses the input to process at a given moment. <quote>Depth first</quote> is
                    equivalent to left-to-right order of the start-markers and start-tags (which may
                    be present in partially flattened input). The Regex replacement method is
                    described only as <quote>left to right</quote> because it does not engage with
                    the input as a tree at all.</para>
                    </listitem>
                    *-->
            <listitem>
                <para><emphasis role="ital">Raising order</emphasis>
                describes the order in which virtual elements in the
                input are raised.  <quote>Left to right</quote>,
                <quote>Inside-out</quote> and
                <quote>outside-in</quote> are as described
                above.</para>
            </listitem>

            <!--*
            <listitem>
                <para>The <emphasis role="ital">Recursive?</emphasis> column describes the means of
                    recursion. The maximum depth of recursion for each recursive method is described
                    below under <xref linkend="comparisons"/>. </para>
            </listitem>
            <listitem>
                <para>The <emphasis role="ital">Stack?</emphasis> column shows the native datatype
                    used by the method to maintain a stack.</para>
            </listitem>
            *-->
            <listitem>
                <para><emphasis role="ital">Passes / Calls</emphasis>
                describes how many passes over the input are made, or
                how many recursive calls to the core function are
                made.</para>
                <para>
                Right-sibling traversal makes a single pass over the
                input, but because it does so using recursive calls to
                to <code>apply-templates</code> which select single
                nodes, the template stack will in theory grow until it
                has one template on the stack for each node in the
                flattened sequence of nodes in the input. (Since the
                calls are tail-recursive, implementations may optimize
                the calls and perform the traversal in constant stack space.)
                </para>
                <para>
                  Regex replacement is easiest to implement in two
                  passes: we replace start-markers globally and then
                  end-markers globally in a pipeline (or vice
                  versa). Matching both types of marker with a single
                  regex is easy, but because the replacements are
                  different (start-markers may contain non-Trojan
                  attributes), the replacement logic may be more
                  complex.
                </para>
                <para>
                  The other left-to-right methods will use template
                  stack space proportional to the depth of the tree, as
                  is common in XSLT stylesheets.
                </para>
                <para>
                  The inside-out method makes one pass over the input
                  for each nesting level in the tree of virtual
                  elements being raised.  On each pass, the entire
                  document is processed, although content elements can
                  typically be handled with <code>copy-of</code>,
                  which means their subtrees do not require template
                  matching.
                </para>
                <para>
                  In the outside-in method, each call to the function
                  raises one virtual element (unless the arguments are
                  all leaves, in which case it raises none), so the
                  total number of calls is proportional to the number
                  of virtual elements.  Each node in the input is
                  passed as (part of) an argument <emphasis
                  role="ital">n</emphasis> + <emphasis
                  role="ital">m</emphasis> times, where <emphasis
                  role="ital">n</emphasis> is 1 plus the number of
                  virtual ancestors the node has (for outermost
                  elements, <emphasis role="ital">n</emphasis>= 1, for
                  their children, 2, etc.), and <emphasis
                  role="ital">m</emphasis> is 1 + the number of
                  preceding siblings the node has in the final output
                  tree.</para>
            </listitem>
            <listitem>
              <para>
                <!--* <emphasis role="ital">Well-formed?</emphasis> *-->
                <emphasis role="ital">Overlap handling</emphasis>
                describes what happens when this method is used on
                input with overlapping virtual elements, where an
                attempt to raise every virtual element would produce
                ill-formed output.
              </para>
              <para>
                <emphasis role="ital">Partial raising, well
                formed</emphasis> means that the method raises some
                but not all virtual elements and produces well-formed
                XML by leaving some markers unraised.
              </para>
              <para>
                <emphasis role="ital">Full raising, ill
                formed</emphasis> means that the method converts all
                start- and end-markers to start- and end-tags without
                any rearrangement or adjustment, even when the result
                is not well formed.
              </para>
              <para>
                <emphasis role="ital">Silent error</emphasis> means
                that the method produces well formed XML output that
                is semantically incorrect: in some cases the method
                includes content within a raised element which does
                not belong there, in other cases content is omitted.
                In all three cases, the absence of any error signal is
                a characteristic of our simple proof-of-concept
                implementations, which were designed to handle input
                without overlapping virtual elements.  All of these
                methods can be implemented with a more thorough
                check of the input, to raise an error, and optionally
                to recover from the situation, in cases involving
                overlapping virtual elements.
              </para>

            </listitem>
        </itemizedlist>
        
    </section>

    <section>
        <title>The problem</title>
        
        <section>
            <title>Raising <emphasis role="ital">Frankenstein</emphasis></title>
            
            <para>As a concrete example, we can consider the form taken by this task in the
                    <emphasis>Variorum Frankenstein</emphasis> [<xref linkend="frankenstein"/>]
                project edited by the second author. In this project, we collate different encodings
                of the novel deriving from five digital sources using the software CollateX [<xref
                    linkend="collatex"/>], which reads the input texts to locate their moments of
                alignment and variation. The process of collation compares XML documents as text
                files, which means that XML tags are treated as text so that strings of text that
                compare structural boundaries like paragraph breaks in one version of a document can
                be aligned with passages containing the same (or nearly the same) text lacking those
                boundaries. CollateX provides XML output that represents in one file the collation
                of all the variant input documents, and its output raises a new hierarchy made
                up of a root element and a flat sequence of TEI critical apparatus elements designed to mark
                where the documents align in comparable and variant passages. When XML elements are
                supplied in the input to the collation process, their tags are returned as text with
                angle brackets escaped, as shown in <xref linkend="CollateX-Thomas_C10"/> below.
            </para>
            
            <para>To prepare the editions for collation we began by flattening the original
                structural markup, converting elements that wrapped volumes, chapters, paragraphs,
                and lines (among others) into self-closed start and end markers. We flattened these
                elements in anticipation of reconstructing them on the other side of the collation
                process. Because we need to retain original markup information in the eventual
                collation output for later use, flattening it allows us to preserve it without
                letting it interfere with the alignment process or the new hierarchical output of
                CollateX. The XML output produced by CollateX includes (as we expect and want) many
                fragmented start and end tags, showing us not only places where paragraph breaks
                occur in one witness to the text but not in the others, but also locations where
                part (but not all) of a deleted passage in the manuscript draft aligns with material
                in the published editions of the novel. In such situations, we wind up with an
                original start-tag inside one container element and its corresponding original
                end-tag inside another, and we cannot reconstruct that element without creating
                overlap. Knowing that the collation process will generate (by design) a hierarchy in
                conflict with the structural markup of our input documents, we prepared the input
                source documents in advance to flatten their hierarchies, because we intended to
                reconstruct the elements later building on the collation output.</para>
            
            <para>Here is an example from the output of CollateX representing a single divergent
                reading in the <quote>Thomas copy</quote> of <emphasis>Frankenstein</emphasis>
                before all witnesses align. (Some line breaks have
                been introduced for legibility.)</para>
            
            <figure xml:id="CollateX-Thomas_C10">
                <programlisting>&lt;app&gt;
    &lt;rdg wit="#fThomas"&gt;
        contortions that ever and anon 
        con&amp;lt;del
            sID="fThomas_C10-del_2"/&amp;gt;puls&amp;lt;del
            eID="fThomas_C10-del_2"/&amp;gt;vulsed
        &amp;amp; deformed his un-human features.
        &amp;lt;p eID="novel1_letter4_chapter4_p133"/&amp;gt;
        &amp;lt;p sID="novel1_letter4_chapter4_p134"/&amp;gt;
        The 
    &lt;/rdg&gt;
&lt;/app&gt;
&lt;app type="invariant"&gt;
    &lt;rdg wit="#f1818"&gt;different accidents of life are &lt;/rdg&gt;
    &lt;rdg wit="#f1823"&gt;different accidents of life are &lt;/rdg&gt;
    &lt;rdg wit="#f1831"&gt;different accidents of life are &lt;/rdg&gt;
    &lt;rdg wit="#fMS"&gt;different accidents of life are &lt;/rdg&gt;
    &lt;rdg wit="#fThomas"&gt;different accidents of life are &lt;/rdg&gt;
&lt;/app&gt;</programlisting>
                <caption>
                    <para>Sample CollateX output</para>
                </caption>
            </figure>
            
            <para>In the example above, there is only one <code>&lt;rdg&gt;</code> element inside
                the first <code>&lt;app&gt;</code> because at this point the Thomas edition contains
                an inserted passage not present in the other editions, which have no material to
                compare with it. Following this point, the witnesses all agree, as shown in the next
                    <code>&lt;app&gt;</code> element. The output actually does not contain markers
                for the virtual <code>&lt;del&gt;</code> and <code>&lt;p&gt;</code> elements but
                rather these have been converted to a string carrying escape characters as a trace
                of their prior existence as elements: <code>&amp;lt;del/&amp;gt;</code> and
                    <code>&amp;lt;p/&amp;gt;</code>.</para>
            <!--* Then why on earth doesn't CollateX emit an empty
                reading to signal explicitly that the other witnesses
                have nothing here?  Even printed apparatus
                will print 'om. AB' to signal an omission in AB ! 
                EB: That seems a small thing to ask, but I can see another argument that this would just produce bloated code: why all those empty <rdg>s? And ultimately, collateX output should be reconstructed into more informative annotations. 
                *-->
            
            <para>Following the collation process, we use the XML output as the basis for
                reconstructing the individual edition files so that they may individually indicate
                    <quote>hotspots</quote>, or passages that vary in the other editions. We wrote
                XSLT to run over the collation XML output to produce a separate file representing each reading
                witness (not shown here for space reasons). In this first stage, we leave all the original marker elements of the edition as escaped strings and we mark each witness’s hotspots with <code>&lt;seg&gt;</code> elements. 
                Because these hotspots will sometimes overlap with structural markup from the input
                editions, we must also insert these elements as flattened start and end markers.
            </para>
            <para>In the next stage, shown in <xref
                linkend="reconstructed-Thomas_C10"/>, we apply an XSLT script with
                    <code>&lt;xsl:analyze-string&gt;</code> to reconstruct the source edition’s
                element markers from the strings.<xref
                    linkend="reconstructed-Thomas_C10"/>: </para>
            <figure xml:id="analyze-string">
                <programlisting>
&lt;xsl:template match="ab/text()"  
 &lt;xsl:analyze-string select="." regex="&amp;lt;.[^/]+?[es]ID=[^/]+?/&amp;gt;"&gt;
 &lt;!--The value of the regex attribute is the string we isolate for conversion into a new element. 
 It begins and ends with a left and right angle bracket and 
 contains the pattern to isolate the original non-namespaced form of our Trojan markers. --&lt;
                        &lt;xsl:matching-substring&gt;
   &lt;xsl:variable name="flattenedTagContents" 
            select="substring-before(., '/') ! substring-after(., '&amp;lt;')"/&gt;
   &lt;xsl:variable name="elementName" 
            select="tokenize($flattenedTagContents, ' ')[1]"/&gt;
                                
   &lt;xsl:element name="{$elementName}"&gt;
   
      &lt;xsl:for-each select="tokenize($flattenedTagContents, ' ')[position() gt 1][contains(., '=')]"&gt;
      &lt;!--In defining the variable below, we apply the Trojan Horse (th:) namespace prefix 
      to the original forms of sID and eID in the input data. If the regular expression 
      matched by [se]ID is found in the string, we concatenate the prefix with the substring before the '=' sign 
      to form the attribute name. Otherwise, the substring before the '=' sign will be the attribute name. --&gt;
           &lt;xsl:variable name="attName" as="xs:string"&gt;
            &lt;xsl:choose&gt;
              &lt;xsl:when test="matches(current(), '[se]ID')"&gt;
                &lt;xsl:value-of select="concat('th:', substring-before(current(), '='))"/&gt;
              &lt;/xsl:when&gt;
              &lt;xsl:otherwise&gt;
                &lt;xsl:value-of select="substring-before(current(), '=')"/&gt;   
              &lt;/xsl:otherwise&gt;
           &lt;/xsl:choose&gt;                                   
          &lt;/xsl:variable&gt;
          &lt;xsl:attribute name="{$attName}"&gt;
              &lt;xsl:value-of select="substring-after(current(), '=&amp;#34;') ! substring-before(., '&amp;#34;')"/&gt;    
          &lt;/xsl:attribute&gt;
    &lt;/xsl:for-each&gt; 
   &lt;/xsl:element&gt;
  &lt;/xsl:matching-substring&gt;
  &lt;xsl:non-matching-substring&gt;
    &lt;!--At this point, we run xsl:analyze-string again 
    to isolate other kinds of strings that represent other kinds of elements. 
    (For example, the Frankenstein project has a number of milestone-style elements 
    that are not intended to be Trojan markers.)
    After running a series of "string-surgeries" to make new elements with xsl:analyze-string, 
    we conclude with &lt;xsl:value-of select="."/&gt; to output what remains as a string.--&gt;
     &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:non-matching-substring&gt;
 &lt;/xsl:analyze-string&gt;
&lt;/xsl:template&gt;
                </programlisting>
                <caption><para>XSLT template to reconstruct element markers from escape-character strings <footnote><para>This particular kind of “raising” from text strings is slightly tangential to the methods we concentrate on this paper, but we include some discussion of it because it is part of the practical use-case prompting our work on this paper, and is likely to be a stage in other projects that require elements to be flattened and raised. The complete XSLT stylesheet for this process is in the <link xlink:href="https://github.com/PghFrankenstein/Pittsburgh_Frankenstein">Frankenstein Variorum GitHub repository</link>, and <link xlink:href="https://github.com/PghFrankenstein/Pittsburgh_Frankenstein/blob/master/collateXPrep/P3-bridgeEditionConstructor.xsl">the stylesheet itself</link> is part three series of transformations in our raising process that may be found in the parent directory, which also holds its <link xlink:href="https://github.com/PghFrankenstein/Pittsburgh_Frankenstein/tree/master/collateXPrep/bridge-P2">input</link> and <link xlink:href="https://github.com/PghFrankenstein/Pittsburgh_Frankenstein/tree/master/collateXPrep/bridge-P3">output</link> directories.</para></footnote></para></caption>
            </figure>
            <para>The script above applies regular expressions to isolate the strings we need to reconstruct the Trojan marker elements of the source edition that were reduced to text in the collation process. Going into the collation none of our files contain namespaces, but we apply them in the up-conversion process, so here we concatenate the <code>th:</code> namespace prefix as we reconstruct our Trojan horse attributes.</para>
                <para>Following this element reconstruction, our next
                task will be to find a way to raise both the original markup we flattened from the
                source editions with the conflicting hierarchy posed by the <code>seg</code>
                elements derived from the collation process. <xref
                linkend="reconstructed-Thomas_C10"/>
                shows a sample passage from the
                Thomas copy edition file with the reconstructed but
                flattened elements (again, white space has been added for legibility):
            </para>
            
            <figure xml:id="reconstructed-Thomas_C10">
                <programlisting>&lt;seg xml:id="C10_app90-fThomas_start"/&gt;
contortions that ever and anon
con&lt;del
    th:sID="fThomas_C10-del_2"/&gt;puls&lt;del th:eID="fThomas_C10-del_2"/&gt;vulsed
&amp;amp; deformed  his un-human features.
&lt;p loc="novel1_letter4_chapter4_p133" ana="end"/&gt; 
&lt;p loc="novel1_letter4_chapter4_p134" ana="start"/&gt;
The
&lt;seg xml:id="C10_app90-fThomas_end"/&gt;</programlisting>
                <caption>
                    <para>Sample reconstruction of the Thomas file, with flattened markup</para>
                </caption>
            </figure>
            
            <para>In the passage above, the empty <code>&lt;seg&gt;</code> elements indicate the
                start and end points of the variant passage in the Thomas copy. Their partially
                shared <code>@xml:id</code> values coindex them while also pointing to the collation
                unit and numbered <code>&lt;app&gt;</code> element in the collation output; the
                trailing underscore separator and the string <code>start</code> or <code>end</code>
                distinguish start- from end-markers. In this example, <code>&lt;seg
                    xml:id="C10_app90-fThomas_start"/&gt;</code> means that this is the start of a
                variant from apparatus unit 90, where the Thomas copy diverges from a reading shared
                by all of the other editions (in this case, the type of variation is that the other
            witnesses have no corresponding reading).</para>
            
            <para>Within the <code>&lt;seg&gt;</code> virtual element, the first two
                    <code>&lt;del&gt;</code> markers (start- and end-) frame a deleted portion of a
                word (<quote>puls</quote>), and the third marks the end of paragraph 133 in Chapter
                4, followed by the beginning of paragraph 134 in the same chapter. The use of
                attributes on <code>&lt;del></code> and <code>&lt;p></code> markers differs from
                that with the <code>&lt;seg&gt;</code> elements; in the case of
                    <code>&lt;del></code> and <code>&lt;p></code>, the Trojan horse attributes point
                to the location in the source and coindexes the start- and end-markers.<footnote>
                    <para>Using different formats for the markup of different flattened elements
                        makes it easy to raise one group of flattened element types while leaving
                        another in its flattened stage. Alternatively, we could use the same
                        attributes for all flattened elements and specify which ones we wanted to
                        raise at the processing stage. <xref linkend="atmo"/> proposes a
                            <code>th:doc</code> attribute for identifying a start- or end-marker as
                        belonging to a particular hierarchy. </para>
                </footnote></para>
            
            <para>While we wish to raise both hierarchies, the primary use case on which we concentrate in this paper is to raise the structural elements from the original edition  (such as <code>&lt;p&gt;</code> and <code>&lt;del&gt;</code>), while leaving the <code>&lt;seg&gt;</code> elements flattened. The question of how best to accomplish this brought the three co-authors together, and serves as a testing ground for the raising methods described in this paper. The output will look something like <xref linkend="raised-Thomas_C10"/> for the end of paragraph 133 and the start of paragraph 134 in the Thomas edition:</para>
            
            <figure xml:id="raised-Thomas_C10">
                <programlisting>&lt;p xml:id="novel1_letter4_chapter4_p133"&gt;
    …
    &lt;seg xml:id="C10_app90-fThomas_start"/&gt;contortions
    that ever and anon
    con&lt;del xml:id="fThomas_C10-del_2"&gt;puls&lt;/del&gt;vulsed
    &amp;amp; deformed his un-human features.
&lt;/p&gt;
&lt;p xml:id="novel1_letter4_chapter4_p134"&gt;
    The &lt;seg xml:id="C10_app90-fThomas_end"/&gt;
    different accidents of life are not so changeable as
    the feelings of human nature
    …
&lt;/p&gt;</programlisting>
                <caption>
                    <para>The sample passage above, after raising structural elements (and
                        reflowing)</para>
                </caption>
            </figure>
            
            <para>A secondary use case is to raise the <code>&lt;seg/&gt;</code> elements. When,
                later in the production process, we also raise the <code>&lt;seg&gt;</code>
                elements, we avoid overlap, or, rather we mark a moment of intersecting hierarchy,
                by fragmenting the one that spans a paragraph boundary
            into two parts:</para>

            
            <figure>
              <!--* MSM moved seg end-tag from before del (immediately
                  after 'con') to end of first paragraph, after
                  consulting input/Frankenstein/novel-coll, where
                  the segment seems to include "pul/vulsed &
                  deformed his un-human features."

                  But do check! EB: Yes, confirmed (even in a new output collation). Thank you!
                  *-->
              
                <programlisting>&lt;p xml:id="novel1_letter4_chapter4_p133"&gt;
    …
    &lt;seg xml:id="C10_app90-fThomas__Pt1"&gt;contortions 
    that ever and anon
    con&lt;del xml:id="fThomas_C10-del_2"
    &gt;puls&lt;/del&gt;vulsed
    &amp;amp; deformed his
    un-human features.
    &lt;/seg&gt;
&lt;/p&gt;
&lt;p xml:id="novel1_letter4_chapter4_p134"&gt;
    &lt;seg xml:id="C10_app90-fThomas__Pt2"&gt;
    The
    &lt;/seg&gt;
    different accidents of life are
    not so changeable as the feelings of human
    nature
    …
&lt;/p&gt;</programlisting>
                <caption>
                    <para>Because raising <code>&lt;seg&gt;</code> would create overlap, we split
                        the element into parts.</para>
                </caption>
            </figure>
            
            <para>The split <code>&lt;seg&gt;</code> elements in the passage above now indicate
                their association with each other with <code>__Pt1</code> and <code>__Pt2</code>
                appended to the original value of the apparatus and
            reading witness location.</para>
            <!--* MSM wonders: if you want to make that kind of
                association explicit, wouldn't @part or @next
                and @prev do that in a more standard way?
                Just asking. *-->
            
            <para>Our process of raising the new edition files thus entails the following steps: <orderedlist>
                    <listitem>
                        <para>Flatten all markup (prior to and following the collation
                            process)</para>
                    </listitem>
                    <listitem>
                        <para>Reconstruct (raise) the structural elements from the source edition
                            (e.g., <code>&lt;p&gt;</code>, <code>&lt;del&gt;</code>)</para>
                    </listitem>
                    <listitem>
                        <para>Raise the <code>&lt;seg&gt;</code> elements, which indicate moments of
                            variation in the collation, splitting the raised elements into parts
                            where that is required to avoid creating overlap</para>
                    </listitem>
                </orderedlist> The experimental transformations tested and discussed in this report
                focus primarily on the middle of these three steps, raising the structural markup.
                <!--2018-07-08 ebb:
                Shall we revisit this in light of our discussions of
                raising seg elements in our process?  --></para>
                
        </section>

        <section xml:id="simplified" xreflabel="Simplified sample data">
            <title>Simplified sample data</title>
            
            <para>In addition to exploring and reporting on the application of different raising
                methods to authentic data from <xref linkend="frankenstein"/>, described above, for
                illustrative and development purposes when discussing program logic we use a small
                contrived hierarchical XML sample extracted from a short passage of poetry, derived
                from a quoted passage in the <emphasis>Frankenstein</emphasis> novel. The simplified
                data comes in three forms, which we call <emphasis role="ital">basic</emphasis>,
                    <emphasis role="ital">extended</emphasis>, and <emphasis role="ital"
                    >overlap</emphasis>.<footnote>
                    <para>All files discussed in this report, as well as the report itself, are
                        available in <link>https://github.com/djbpitt/raising</link>.</para>
                </footnote></para>
            
            <section xml:id="simplified-original">
                <title>Basic sample</title>
                
                <para>A sample of the basic input format in its
                original form is:</para>
                
                <figure>
                    <programlisting><![CDATA[<p> 
    <cit> 
        <quote> 
            <lg> 
                <l> Like one who, on a lonely road, </l>
                <l> Doth walk in fear and dread, </l>
                <l> And, having once turn’d round, walks on, </l>
                <l> And turns no more his head; </l>
                <l> Because he knows a frightful fiend </l>            
                <l> Doth close behind him tread*. </l>
            </lg>
        </quote>
        <note> * 
        <bibl> 
            Coleridge’s “Ancient Mariner.” 
        </bibl>
        </note>
    </cit>
</p>
]]></programlisting>
                    <caption>
                        <para>Original hierarchical XML</para>
                    </caption>
                </figure>
                
            </section>
            
            <section>
                <title>Flattening</title>
                
                <para>To test the method on our <xref linkend="simplified"/>, we first flatten the
                    original XML with the following XSLT, which converts all tags except the root
                    (which must be preserved as a container element to ensure that the XML is well
                    formed) to Trojan milestones. We modify the Trojan milestone markup method
                    described in <xref linkend="derose_2004"/> by putting the <code>@sID</code> and
                        <code>@eID</code> attributes in a namespace, for which we bind the prefix
                        <code>th:</code> to the URI
                        <code>http://www.blackmesatech.com/2017/nss/trojan-horse</code>
                        (following <xref linkend="atmo"/>). The
                    original generic identifier is retained, the start-tag is replaced by an empty
                    element that adds a <code>@th:sID</code> attribute with a generated value, and
                    the end-tag is replaced by an empty element that adds a <code>th:eID</code>
                attribute with the same generated value:</para>
                
                <figure>
                    <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:th="http://www.blackmesatech.com/2017/nss/trojan-horse"
    xmlns:math="http://www.w3.org/2005/xpath-functions/math"
    exclude-result-prefixes="#all"
    version="3.0"&gt;
    &lt;xsl:output method="xml" indent="no"/&gt;
    &lt;xsl:template match="/*"&gt;
        &lt;xsl:copy&gt;
          &lt;xsl:namespace name="th"
            select="'http://www.blackmesatech.com/2017/nss/trojan-horse'"/&gt;
            &lt;xsl:apply-templates/&gt;
        &lt;/xsl:copy&gt;
    &lt;/xsl:template&gt;
    &lt;xsl:template match="*"&gt;
        &lt;xsl:element name="{name()}"&gt;
            &lt;xsl:copy-of select="@*"/>
            &lt;xsl:attribute name="th:sID" select="generate-id()"/&gt;
        &lt;/xsl:element&gt;
        &lt;xsl:apply-templates/&gt;
        &lt;xsl:element name="{name()}"&gt;
            &lt;xsl:attribute name="th:eID" select="generate-id()"/&gt;
        &lt;/xsl:element&gt;
    &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</programlisting>
                    <caption>
                        <para>XSLT to flatten hierarchical XML to Trojan milestones</para>
                    </caption>
                </figure>
                
                <para>The flattened version looks roughly like the
		following (line breaks have been added within tags
		here, to shorten the lines:</para>
                
                <figure>
                    <programlisting><![CDATA[<?xml version="1.0" encoding="UTF-8"?><p 
        xmlns:th="http://www.blackmesatech.com/2017/nss/trojan-horse"> 
    <cit th:sID="d1e3"/> 
        <quote th:sID="d1e5"/> 
            <lg th:sID="d1e7"/> 
                <l th:sID="d1e9"
	        /> Like one who, on a lonely road, <l th:eID="d1e9"/>
                <l th:sID="d1e12"
		/> Doth walk in fear and dread, <l th:eID="d1e12"/>
                <l th:sID="d1e15"
		/> And, having once turn’d round, walks on, <l th:eID="d1e15"/>
                <l th:sID="d1e18"
		/> And turns no more his head; <l th:eID="d1e18"/>
                <l th:sID="d1e21"
		/> Because he knows a frightful fiend <l th:eID="d1e21"/>            
                <l th:sID="d1e25"
		/> Doth close behind him tread*. <l th:eID="d1e25"/>
            <lg th:eID="d1e7"/>
        <quote th:eID="d1e5"/>
        <note th:sID="d1e30"/> * 
        <bibl th:sID="d1e32"/> 
            Coleridge’s “Ancient Mariner.” 
        <bibl th:eID="d1e32"/>
        <note th:eID="d1e30"/>
    <cit th:eID="d1e3"/>
</p>]]></programlisting>
                    <caption>
                        <para>Original XML after flattening with Trojan milestones</para>
                    </caption>
                </figure>
                
                <para>The output of raising must match the original
                XML.</para>
                
            </section>
            
            <section>
                <title>Extended basic sample</title>
                
                <para>The basic sample contains no non-Trojan empty elements and no non-Trojan
                    attributes. We can test whether those features are handled properly with the
                    following slightly more complicated sample:</para>
                
                <figure>
                    <programlisting><![CDATA[<?xml version="1.0" encoding="UTF-8"?><p
    xmlns:th="http://www.blackmesatech.com/2017/nss/trojan-horse"> 
  <cit xml:id="fThomas_C10-cit_1" th:sID="d1e3"/> 
  <quote xml:id="fThomas_C10-quote_1" th:sID="d1e5"/> 
  <lg xml:id="fThomas_C10-lg_1" th:sID="d1e7"/> 
  <l xml:id="fThomas_C10-l_1" th:sID="d1e9"
  /> Like one who, on a lonely road, <l th:eID="d1e9"/>
  <l xml:id="fThomas_C10-l_2" th:sID="d1e12"
  /> Doth walk in fear and dread, <l th:eID="d1e12"/>
  <l xml:id="fThomas_C10-l_3" th:sID="d1e15"
  /> And, having once turn’d round, walks on, <l th:eID="d1e15"/>
  <l xml:id="fThomas_C10-l_4" th:sID="d1e18"
  /> And turns no more his head; <l th:eID="d1e18"/>
  <l xml:id="fThomas_C10-l_5" th:sID="d1e21"
  /> Because he knows a frightful fiend <l th:eID="d1e21"/>            
  <l xml:id="fThomas_C10-l_6" th:sID="d1e25"
  /> Doth close behind him tread*. <l th:eID="d1e25"/>
  <lg th:eID="d1e7"/>
  <quote th:eID="d1e5"/>
  <note xml:id="fThomas_C10-note_1" th:sID="d1e30"/> * 
  <bibl xml:id="fThomas_C10-bibl_1">
    Coleridge’s “Ancient Mariner.” 
  </bibl>
  <note th:eID="d1e30"/>
  <cit th:eID="d1e3"/>
</p>
]]></programlisting>
                    <caption>
                        <para>Extended basic sample input</para>
                    </caption>
                </figure>
                
                <para> The extended basic sample adds the following features: <itemizedlist>
                <listitem>
                  <para>The <code>bibl</code> element a
                  non-Trojan element, without Trojan
                  attributes.</para>
                </listitem>
                <listitem>
                  <para>Most elements have, in addition to their Trojan attributes,
                  <code>@xml:id</code> attributes. The Trojan attributes must be
                  removed during raising, but the non-Trojan attributes must be
                  retained.</para>
                </listitem>
              </itemizedlist>
                </para>
            </section>
            
            <section>
                <title>Overlapping markers</title>
                
                <para>To test the behavior of the methods with input that cannot be fully raised
                    without creating overlap, we use the following
                sample (some whitespace added for legibility):</para>
                
                <figure>
                    <programlisting><![CDATA[<!--* Example adapted from LMNL sawtooth syntax
    * at http://piez.org/wendell/LMNL/lmnl-page.html
    *-->
<excerpt xmlns:th="http://www.blackmesatech.com/2017/nss/trojan-horse">
    <source th:sID="source"/>The Housekeeper<source th:eID="source"/>
    <author th:sID="author"/>Robert Frost<author th:eID="author"/>
    <s th:sID="s1"/>
    <l th:sID="L144" n="144"/>
    He manages to keep the upper hand
    <l th:eID="L144"/>
    <l n="145" th:sID="L145"/>
    On his own farm.
    <s th:eID="s1"/>
    <s th:sID="s2"/>
    He's boss.
    <s th:eID="s2"/>
    <s th:sID="s3"/>
    But as to hens:
    <l th:eID="L145"/>
    <l n="146" th:sID="L146"/>
    We fence our flowers in and the hens range.
    <l th:eID="L146"/>
    <s th:eID="s3"/>
</excerpt>
]]></programlisting>
                    <caption>
                        <para>Flattened XML that cannot be raised without creating overlap</para>
                    </caption>
                </figure>
                
                <para>This consists of a few lines of verse, marked up
		with both the metrical structure (verse lines) and the
		division into sentences; both the first and third
		sentences span verse boundaries.</para>
                
            </section>
            
          <!--2018-07-23 ebb: The original version of this section is no longer relevant, since I've changed the Frankenstein markers to @th:sID and @th:eID. But I'll rewrite to call attention to the differently encoded <seg> elements.-->  <section xml:id="marker-styles">
                <title><emphasis role="ital">Frankenstein</emphasis>
                markers</title>
                
              <!--  <para>For historical reasons, the markers in the <emphasis role="ital"
                        >Frankenstein</emphasis> data differ from those of our simplified test
                    sample. Specifically, start-markers in <emphasis role="ital"
                        >Frankenstein</emphasis> have an <code>@ana</code> attribute with the value
                        <code>start</code>, end-tags have an <code>@ana</code> attribute with the
                    value <code>end</code>, and start- and end-tags are coindexed by sharing a
                    unique value of a <code>@loc</code> attribute. The output requirements include
                    removing the <code>@ana</code> attribute and refactoring the <code>@loc</code>
                    attribute as an <code>@xml:id</code>
                attribute.</para>-->
              <para>The Frankenstein Variorum encoding represents an overlapping virtual hierarchy, so we need a way of distinguishing one set of elements participating in one hierarchy from the other set. The virtual elements participating in the first hierarchy hold trojan markers with attributes in the form of <code>@th:sID</code> and <code>@th:eID</code>. The second hierarchy is signalled with an alternative marker style used only on the <code>&lt;seg&gt;</code> elements. Here there is an <code>@xml:id</code> bearing a flag indicating the start or end position of a variant passage. These markers cannot be raised in exactly the way they were placed, since in some cases a variant passage may start inside a paragraph or chapter, and end in the next one. In this project, the decision to raise the <code>&lt;seg&gt;</code> elements necessitates a process of splitting them into pieces within structural boundaries, so that the original virtual element becomes two elements, with part one inside one structural unit and part two inside the next. Different styles of markers here facilitates handling these elements at different moments in the raising process.</para>
            </section>
            
</section>

</section>

    <section>
        <title>Solutions to the problem</title>

	<para>We describe several solutions to the problem, some
	formulated in XSLT 3.0 and some using other tools.</para>
	
        <section>
            <title>Right-sibling traversal</title>
            
            <para>One way to construct content elements from flattened
            XML is to do roughly what a recursive-descent parser for
            XML does: when a recursive-descent parser sees the
            beginning of any construct, it calls a routine to handle
            that construct; if the construct contains other
            constructs, other routines are called recursively. The
            function handling a parent element starts before any
            function handling a child, and ends only after all
            children have been processed.  </para>

	    <para>The standard idiom of including
	    <code>xsl:apply-templates</code> similarly visits each
	    node in the input tree left to right, in order, but
	    provides no mechanism for passing results or state from
	    one sibling to the next.  In order to perform the raising
	    task, we perform instead a <emphasis
	    role="ital">right-sibling traversal</emphasis> of the
	    input tree, which proceeds one element at a time
	    processing along the following-sibling axis. Each marker
	    element calls <code>&lt;xsl:apply-templates&gt;</code>
	    only on its first child, and each template passes control
	    to its immediate right sibling.</para>

	    <section>
	      <title>Order of raising the elements</title>

	    <para><xref
            linkend="visit-LR-01"/> through <xref
            linkend="visit-LR-34"/> illustrate some stages in the 
            process of raising the virtual elements in the sample
	    document by progressing through the flat sequence
	    of siblings which makes up most of the input.</para>

	    <!--* MSM has commented out many of the figures,
		but the files are there and the selection can be
		changed. *-->

	    <figure xml:id="visit-LR-01">
	      <mediaobject>
		<imageobject>
		  <imagedata format="png" width="100%" fileref="images/left-right/Bal2018Birn050501.png"/>
		</imageobject>
	      </mediaobject>
	      <caption>
		<para>Illustration of left-right handling of input by
		a recursive-descent parser or by the left-right method
		described in the text. Initial state.</para>
		<para>The input is shown arrayed along the bottom of
		the diagram:  ovals filled with gray denote start- and
		end-markers, rectangles denote text nodes.  The gray
		ovals above denote the logical hierarchy which is to
		be constructed (visible to human observers even if not
		visible to the software).</para>
	      </caption>
	    </figure>
	    <figure xml:id="visit-LR-02">
	      <mediaobject>		
		<imageobject>
		  <imagedata format="png" width="100%" fileref="images/left-right/Bal2018Birn050502.png"/>
		</imageobject>
	      </mediaobject>
	      <caption>
		<para>The first input node is read and recognized as
		the start-marker for the <code>p</code> element.
		Both the start-marker and the element node constructed
		are shown in red, as is the arc connecting them.</para>
	      </caption>
	    </figure>
	    <figure xml:id="visit-LR-03">
	      <mediaobject>		
		<imageobject>
		  <imagedata format="png" width="100%" fileref="images/left-right/Bal2018Birn050503.png"/>
		</imageobject>
	      </mediaobject>
	      <caption>
		<para>The second input node is read and recognized as
		the start-marker for the citation element  <code>cit</code>.</para>
		<para>The start-marker for the enclosing
		<code>p</code> element has served its purpose and is omitted
		from the diagram.  The node for the <code>p</code>
		element is still incomplete, as indicated by its
		pink background.
		</para>
	      </caption>
	    </figure>
	    <figure xml:id="visit-LR-04">
	      <mediaobject>		
		<imageobject>
		  <imagedata format="png" width="100%" fileref="images/left-right/Bal2018Birn050504.png"/>
		</imageobject>
	      </mediaobject>
	      <caption>
		<para>The third input node is read and recognized as
		the start-marker for the citation element <code>cit</code>.</para>
	      </caption>
	    </figure>

	    <!--*
	    
	    <figure xml:id="visit-LR-05">
	      <mediaobject>		
		<imageobject>
		  <imagedata format="png" width="100%" fileref="images/left-right/Bal2018Birn050505.png"/>
		</imageobject>
	      </mediaobject>
		<para>The fourth input node is read and recognized as
		the start-marker for the line-group element <code>lg</code>.</para>
	    </figure>
	    <figure xml:id="visit-LR-06">
	      <mediaobject>		
		<imageobject>
		  <imagedata format="png" width="100%" fileref="images/left-right/Bal2018Birn050506.png"/>
		</imageobject>
	      </mediaobject>
		<para>The fifth input node is read and recognized as
		the start-marker for the first line of verse.</para>
	    </figure>
	    <figure xml:id="visit-LR-07">
	      <mediaobject>		
		<imageobject>
		  <imagedata format="png" width="100%" fileref="images/left-right/Bal2018Birn050507.png"/>
		</imageobject>
	      </mediaobject>
		<para>The sixth input node is the text node contained
		in the first line of verse.</para>
	    </figure>
	    <figure xml:id="visit-LR-08">
	      <mediaobject>		
		<imageobject>
		  <imagedata format="png" width="100%" fileref="images/left-right/Bal2018Birn050508.png"/>
		</imageobject>
	      </mediaobject>
		<para>The seventh input node is read and recognized as
		the end-marker for the first line of verse.</para>
		</figure>
		*-->

	    
	    <para>Between <xref linkend="visit-LR-04"/>
	    and <xref linkend="visit-LR-09"/>, we elide several
	    stages.  <xref linkend="visit-LR-09"/> through
	    and <xref linkend="visit-LR-11"/> illustrate the
	    complete recognition of the second line of verse.
	    </para>
	    
	    <figure xml:id="visit-LR-09">
	      <mediaobject>		
		<imageobject>
		  <imagedata format="png" width="100%" fileref="images/left-right/Bal2018Birn050509.png"/>
		</imageobject>
	      </mediaobject>
		<para>The eighth input node is read and recognized as
		the start-marker for the second line of verse.</para>
		<para>The first line of verse is now complete and its
		node is now shown with black oval and white background
		instead of pink.</para>
	    </figure>
	    
	    <figure xml:id="visit-LR-10">
	      <mediaobject>		
		<imageobject>
		  <imagedata format="png" width="100%" fileref="images/left-right/Bal2018Birn050510.png"/>
		</imageobject>
	      </mediaobject>
		<para>The ninth input node is the text
		for the second line of verse.</para>
	    </figure>
	    <figure xml:id="visit-LR-11">
	      <mediaobject><imageobject>
		<imagedata format="png" width="100%"
			   fileref="images/left-right/Bal2018Birn050511.png"/>
	      </imageobject></mediaobject>
	      <caption>
		<para>End-marker for second line of verse.</para>
	      </caption>
	    </figure>

	    <!--* 
	    <figure xml:id="visit-LR-12">
	      <mediaobject><imageobject>
		<imagedata format="png" width="100%"
			   fileref="images/left-right/Bal2018Birn050512.png"/>
	      </imageobject></mediaobject>
	      <caption>
		<para>Start-marker for third line of verse.</para>
	      </caption>
	    </figure>	    
	    <figure xml:id="visit-LR-13">
	      <mediaobject><imageobject>
		<imagedata format="png" width="100%"
			   fileref="images/left-right/Bal2018Birn050513.png"/>
	      </imageobject></mediaobject>
	      <caption>
		<para>Text of third line of verse.</para>
	      </caption>
	    </figure>
	    <figure xml:id="visit-LR-14">
	      <mediaobject><imageobject>
		<imagedata format="png" width="100%"
			   fileref="images/left-right/Bal2018Birn050514.png"/>
	      </imageobject></mediaobject>
	      <caption>
		<para>End-marker for third line of verse.</para>
	      </caption>
	    </figure>
	    <figure xml:id="visit-LR-15">
	      <mediaobject><imageobject>
		<imagedata format="png" width="100%"
			   fileref="images/left-right/Bal2018Birn050515.png"/>
	      </imageobject></mediaobject>
	      <caption>
		<para>Start-marker for the fourth line of verse.</para>
	      </caption>
	    </figure>	    
	    <figure xml:id="visit-LR-16">
	      <mediaobject><imageobject>
		<imagedata format="png" width="100%"
			   fileref="images/left-right/Bal2018Birn050516.png"/>
	      </imageobject></mediaobject>
	      <caption>
		<para>Text of fourth line of verse.</para>
	      </caption>
	    </figure>
	    <figure xml:id="visit-LR-17">
	      <mediaobject><imageobject>
		<imagedata format="png" width="100%"
			   fileref="images/left-right/Bal2018Birn050517.png"/>
	      </imageobject></mediaobject>
	      <caption>
		<para>End-marker for fourth line of verse.</para>
	      </caption>
	    </figure>
	    <figure xml:id="visit-LR-18">
	      <mediaobject><imageobject>
		<imagedata format="png" width="100%"
			   fileref="images/left-right/Bal2018Birn050518.png"/>
	      </imageobject></mediaobject>
	      <caption>
		<para>Start-marker for fifth line of verse.</para>
	      </caption>
	    </figure>	    
	    <figure xml:id="visit-LR-19">
	      <mediaobject><imageobject>
		<imagedata format="png" width="100%"
			   fileref="images/left-right/Bal2018Birn050519.png"/>
	      </imageobject></mediaobject>
	      <caption>
		<para>Text for fifth line of verse.</para>
	      </caption>
	    </figure>
	    <figure xml:id="visit-LR-20">
	      <mediaobject>		
		<imageobject>
		  <imagedata format="png" width="100%" fileref="images/left-right/Bal2018Birn050520.png"/>
		</imageobject>
	      </mediaobject>
		<para>End-marker for fifth line of verse.</para>
	    </figure>
	    <figure xml:id="visit-LR-21">
	      <mediaobject><imageobject>
		<imagedata format="png" width="100%"
			   fileref="images/left-right/Bal2018Birn050521.png"/>
	      </imageobject></mediaobject>
	      <caption>
		<para>Start-marker for sixth line of verse.</para>
	      </caption>
	    </figure>
	    <figure xml:id="visit-LR-22">
	      <mediaobject><imageobject>
		<imagedata format="png" width="100%"
			   fileref="images/left-right/Bal2018Birn050522.png"/>
	      </imageobject></mediaobject>
	      <caption>
		<para>Content of sixth line of verse.</para>
	      </caption>
	    </figure>	    
	    <figure xml:id="visit-LR-23">
	      <mediaobject><imageobject>
		<imagedata format="png" width="100%"
			   fileref="images/left-right/Bal2018Birn050523.png"/>
	      </imageobject></mediaobject>
	      <caption>
		<para>End-marker for sixth line of verse.</para>
	      </caption>
	    </figure>
	    <figure xml:id="visit-LR-24">
	      <mediaobject><imageobject>
		<imagedata format="png" width="100%"
			   fileref="images/left-right/Bal2018Birn050524.png"/>
	      </imageobject></mediaobject>
	      <caption>
		<para>End-marker for third line of verse.</para>
	      </caption>
	    </figure>
	    <figure xml:id="visit-LR-25">
	      <mediaobject><imageobject>
		<imagedata format="png" width="100%"
			   fileref="images/left-right/Bal2018Birn050525.png"/>
	      </imageobject></mediaobject>
	      <caption>
		<para>End-marker for the line group.</para>
	      </caption>
	    </figure>	    
	    <figure xml:id="visit-LR-26">
	      <mediaobject><imageobject>
		<imagedata format="png" width="100%"
			   fileref="images/left-right/Bal2018Birn050526.png"/>
	      </imageobject></mediaobject>
	      <caption>
		<para>End-marker for the quotation.</para>
	      </caption>
	    </figure>
	    <figure xml:id="visit-LR-27">
	      <mediaobject><imageobject>
		<imagedata format="png" width="100%"
			   fileref="images/left-right/Bal2018Birn050527.png"/>
	      </imageobject></mediaobject>
	      <caption>
		<para>Start-marker for the <code>note</code> element.</para>
	      </caption>
	    </figure>
	    <figure xml:id="visit-LR-28">
	      <mediaobject><imageobject>
		<imagedata format="png" width="100%"
			   fileref="images/left-right/Bal2018Birn050528.png"/>
	      </imageobject></mediaobject>
	      <caption>
		<para>Text node directly contained within
		<code>note</code> element.</para>
	      </caption>
	    </figure>	    
	    <figure xml:id="visit-LR-29">
	      <mediaobject><imageobject>
		<imagedata format="png" width="100%"
			   fileref="images/left-right/Bal2018Birn050529.png"/>
	      </imageobject></mediaobject>
	      <caption>
		<para>Start-marker for bibliographic information
		element (<code>bibl</code>).</para>
	      </caption>
	    </figure>
	    <figure xml:id="visit-LR-30">
	      <mediaobject>		
		<imageobject>
		  <imagedata format="png" width="100%" fileref="images/left-right/Bal2018Birn050530.png"/>
		</imageobject>
	      </mediaobject>
		<para>Text content of <code>bibl</code> element.</para>
	    </figure>
	    <figure xml:id="visit-LR-31">
	      <mediaobject><imageobject>
		<imagedata format="png" width="100%"
			   fileref="images/left-right/Bal2018Birn050531.png"/>
	      </imageobject></mediaobject>
	      <caption>
		<para>End-marker for <code>bibl</code> element.</para>
	      </caption>
	      </figure>
	      *-->

	    <para><xref linkend="visit-LR-32"/> through
	    and <xref linkend="visit-LR-34"/> illustrate the
	    recognition of the last two end-markers and the final
	    state of processing.
	    </para>
	    
	    <figure xml:id="visit-LR-32">
	      <mediaobject><imageobject>
		<imagedata format="png" width="100%"
			   fileref="images/left-right/Bal2018Birn050532.png"/>
	      </imageobject></mediaobject>
	      <caption>
		<para>End-marker for <code>cit</code> element.</para>
	      </caption>
	    </figure>	    
	    <figure xml:id="visit-LR-33">
	      <mediaobject><imageobject>
		<imagedata format="png" width="100%"
			   fileref="images/left-right/Bal2018Birn050533.png"/>
	      </imageobject></mediaobject>
	      <caption>
		<para>End-marker for paragraph.</para>
	      </caption>
	    </figure>
	    <figure xml:id="visit-LR-34">
	      <mediaobject><imageobject>
		<imagedata format="png" width="100%"
			   fileref="images/left-right/Bal2018Birn050534.png"/>
	      </imageobject></mediaobject>
	      <caption>
		<para>Final state:  all markers are gone, and all
		elements have been raised.</para>
	      </caption>
	    </figure>

	    </section>
	    <section>
	      <title>Outline of XSLT code</title>
	    		
        	
        <para>As described above, the <emphasis role="ital">right-sibling traversal</emphasis> idiom
                    in XSLT proceeds one element at a time along the following-sibling axis. In the
                    general case, each template for a content element calls
                        <code>&lt;xsl:apply-templates&gt;</code> not on all its children but only on
                    its first child. Every template (for content elements, marker elements, text
                    nodes, comments, or processing instructions) concludes with a call to
                        <code>&lt;xsl:apply-templates
                    select="following-sibling::node()[1]"/></code>, thus passing control to the
                    template for its immediate right sibling. In the flattening case, the outermost
                    element of the document may be the only content element and its template the
                    only one that applies templates to its children. </para>
	<para>For our simple test cases, processing begins
	with the template for the outermost element.<footnote>
	<para>If the flat content is contained not in the outermost element but in some other container
                            element, all nodes outside the flattened region can be copied to the
                            output without change. In this case the template for the container
                            element will be responsible for shifting from the mode for identity
                            transformation to the mode for element raising, and will have a more
                            selective <code>match</code> pattern.</para>
      </footnote>
	</para>
	<figure>
	  <programlisting><![CDATA[<xsl:template match="*[*]">
    <xsl:copy copy-namespaces="no">
      <xsl:copy-of select="@*"/>
      <xsl:apply-templates mode="raising"
                           select="child::node()[1]"/>
    </xsl:copy>    
  </xsl:template>]]></programlisting>
	</figure>
      <para>
	The template for start-markers constructs a content element
	for the corresponding virtual element; it has the following
	structure:
      </para>

      <figure>
        <programlisting><![CDATA[<xsl:template match="*[@th:sID]" mode="raising">
    
    <!--* 1: handle this element *-->
    <xsl:copy>
      <xsl:copy-of select="@* except @th:sID"/>
      <xsl:apply-templates select="following-sibling::node()[1]"
                   mode="raising">
      </xsl:apply-templates>
    </xsl:copy>
      
    <!--* 2: continue after this element *-->
    <xsl:apply-templates select="following-sibling::*
                         [@th:eID = $sID 
                         and namespace-uri()=$ns
                         and local-name()=$ln]
                         /following-sibling::node()[1]"
                 mode="raising"/>

</xsl:template>]]></programlisting>
        <caption>
          <para>Template for start-marker</para>
        </caption>
      </figure>
      
            <para>Note that there are two calls to <code>&lt;xsl:apply-templates&gt;</code>. The
                    first call to <code>&lt;xsl:apply-templates&gt;</code> occurs within an
                        <code>&lt;xsl:copy&gt;</code> element (which constructs an element with the
                    name and attributes given by the start-marker); it selects the immediately
                    following sibling node, which will in the normal run of things become the first
                    child node of the new content element. The second call to
                        <code>&lt;xsl:apply-templates&gt;</code> occurs after the new content
                    element and it does <emphasis>not</emphasis> select the start-marker’s immediately following sibling, but instead selects the node <emphasis>immediately to the right of the end-marker</emphasis>.</para>
            
            <para>Each child of the virtual element copies itself into the content element being
                created. The templates for <code>text()</code> nodes, comments, processing
                instructions, and any content elements present in the input all have essentially the
            same structure:</para>
            
            <figure>
                <programlisting><![CDATA[<xsl:template match="text() | comment() | processing-instruction | *[not(@th:*)]"
        mode="raising">
    <xsl:copy-of select="."/>
    <xsl:apply-templates 
        select="following-sibling::node()[1]"
        mode="raising"/>
</xsl:template>]]></programlisting>
                <caption>
                    <para>Template for <code>text()</code> nodes, comments, processing instructions,
                        and content elements</para>
                </caption>
            </figure>
            
            <para>If content elements can contain further markers at other levels of the tree, the
                    <code>&lt;xsl:copy-of&gt;</code> should be replaced by a shallow copy and a
                recursive <code>&lt;xsl:apply-templates select="child::node()[1]&gt;</code>. That is
            not the case with our test data.</para>
            
            <para>When an end-marker is encountered, the contents of the virtual element whose end
                    it marks have now all been accumulated, and the right-sibling traversal of the
                    input should stop. The template for end-markers will thus look like this:</para>
            
            <figure>
                <programlisting><![CDATA[<xsl:template match="*[@th:eID]" mode="raising">
        
    <!--* No action necessary *-->
    <!--* We do NOT recur to our right.
        * We leave it to our parent to do that.
        *-->      
    
</xsl:template>]]></programlisting>
                <caption>
                    <para>Empty template to stop the processing of end-markers</para>
                </caption>
            </figure>

	    <para>The code shown here is simplified by assuming
	    that the start- and end-markers in its input correspond
	    to the start- and end-tags of a well-formed XML
	    document.  The template for end-markers, for example,
	    does not check to see that the end-marker found is the
	    one that matches the element on the top of the current
	    element stack.  When confonted with the overlapping
	    virtual elements of some of our sample input, therefore,
	    the code shown here will behave as if start- and
	    end-markers were paired up by position, without regard for
	    co-indexing or element type.  	    
	    </para>
	    
	    <para>Better behavior in the presence of overlapping
	    virtual elements or errors in the input can be achieved
	    by passing parameters on each call to
	    <code>apply-templates</code> in mode <code>raising</code>,
	    which keep a stack of co-indexing IDs and element types.
	    </para>
	    </section>
	    <section>
	      <title>Resource consumption</title>
	      <para>A few notes on resource consumption may be
	      in order.</para>
	      
              <para>The templates shown each handle a single node and then call
                        <code>&lt;xsl:apply-templates&gt;</code>, selecting the next node to be
                    processed. The template activation stack in the XSLT processor thus contains no
                    sets of nodes waiting to be processed, but the call stack may become rather
                    deep: in our sample data, the maximum depth of the template stack is the number
                    of nodes in the flattened portion of the input. An XSLT processor that does not
                    eliminate tail-recursive template calls may thus run out of stack space (at
                    least in theory—in practice, we have never seen a right-sibling recursion blow
                    the stack on real, well-formed input).</para>
              <para>Because the right-sibling idiom visits each node
	      in the flattened input just once, the cost of the process
	      should be linear in the size of the input.  (In practice,
	      preliminary measurements suggest that with the Saxon
	      HE processor, the rise in cost is sub-linear to the rise
	      in input size.)</para>
	      <!--* Need to check with Exselt. *-->
	      <!--* Need to check with xsltproc. *-->
	      <!--* Need to draw plots of runtimes. *-->

	      <para>Despite its virtues, the right-sibling traveral
	      idiom is needed rarely enough in XSLT programming
	      that many XSLT authors have never used it; some find it
	      difficult.<footnote>
	      <para>And even those who don’t admit to finding it difficult may find it easy to slip up in
                            the details when implementing a right-sibling traversal; see below
                                (<xref linkend="errors-rst"/>).</para>
	      </footnote>
	      The inside-out algorithm described below
	      (<xref linkend="inside-out-function"/>)
	      can be regarded as an alternative which
	      is closer to conventional XSLT usage.  The
	      implementation using XSLT 3.0 accumulators
	      is another approach worth learning.
	      <!--* MSM seems to be deciding that
		  * this is a self-help paper.  Things
		  * you should learn, as an XSLT programmer.
		  * If you don't like that slant, change it.
		  *-->
	      </para>
            </section>

	  <!--* Does the adaptation to Frankenstein require
	      discussion? *-->
            <section>
                <title>Raising
                <emphasis>Frankenstein</emphasis></title>
                
                <para>For raising <emphasis>Frankenstein</emphasis> using right-sibling traversal,
                    we adapt the code lightly to apply to its project markup in the following
                template rules:</para>
                
                <figure>
                    <programlisting>
     &lt;xsl:template match="div[@type='collation']"&gt;
     &lt;xsl:apply-templates select="child::node()[1]" mode="raising"/&gt;
 &lt;/xsl:template&gt;  
    &lt;xsl:template match="*[@th:sID]" mode="raising"&gt;     
        &lt;xsl:variable name="ln" as="xs:string" select="name()"/&gt;
        &lt;xsl:variable name="sID" as="xs:string" select="@th:sID"/&gt;
        
        &lt;!--* 1: handle this element *--&gt;
        &lt;xsl:copy&gt;
           &lt;xsl:attribute name="xml:id"&gt;
               &lt;xsl:value-of select="$sID"/&gt;
           &lt;/xsl:attribute&gt;
            &lt;xsl:apply-templates select="following-sibling::node()[1]" mode="raising"&gt;
            &lt;/xsl:apply-templates&gt;
        &lt;/xsl:copy&gt;
        
        &lt;!--* 2: continue after this element *--&gt;
      &lt;xsl:apply-templates select="following-sibling::*
            [@th:eID= $sID 
            and name()=$ln]
            /following-sibling::node()[1]"
            mode="raising"&gt;
        &lt;/xsl:apply-templates&gt;
    &lt;/xsl:template&gt;
  &lt;xsl:template match="text() | comment() | processing-instruction | *[not(@loc)]"
        mode="raising"&gt;
        &lt;xsl:copy-of select="."/&gt;
        &lt;xsl:apply-templates 
            select="following-sibling::node()[1]"
            mode="raising"/&gt;
    &lt;/xsl:template&gt;
    &lt;xsl:template match="*[@th:eID]" mode="raising"/&gt;
                </programlisting>
                    <caption>
                        <para>Right sibling traversal method applied to
                                <emphasis>Frankenstein</emphasis></para>
                    </caption>
                </figure>
                
            </section>

	    <!--* MSM doesn't think the 1.0 implementation (which does
		now exist) merits a separate subsection.  So I'm
		commenting this out.
		*-->
	    <!--*
            <section>
                <title>XSLT 1.0</title>
                
                <para>
                    <emphasis>For purposes of performance measurement, we expect to implement this
                        algorithm in both XSLT 1.0 and XSLT 2.0 or 3.0. At the time of submission,
                        no XSLT 1.0 version is available.</emphasis>
                </para>
                
            </section>
	    *-->
            
        </section>
        <section xml:id="inside-out-function" xreflabel="Inside-out recursion">
            <title>Inside-out recursion</title>
            
            <para>Inside-out recursion works by finding all innermost pairs of start- and
                end-markers, that is, those that mark virtual elements that do not contain any
                markers or other virtual elements. They may contain anything else, including
                    <code>text()</code> nodes, empty elements that are not markers, and container
                elements. The transformation forms all innermost pairs that it finds into container
                elements and passes the resulting new document back into the recursive function,
                where the (new) innermost pairs of markers are now outside the newly created
                container elements. The function recurs until there are no more markers. The maximum
                possible depth of recursion is equal to the depth of the original (pre-flattening)
            XML hierarchy.</para>
            <para>The sequence in which virtual elements in our sample
	    document are raised in this method is illustrated by the
	    diagrams in <xref linkend="visit-IO-start"/> to <xref
	    linkend="visit-IO-end"/>.</para>


	    <figure xml:id="visit-IO-start">
	      <mediaobject>
		<imageobject>
		  <imagedata format="png" width="100%" fileref="images/inside-out/Bal2018Birn050540.png"/>
		</imageobject>
	      </mediaobject>
	      <caption>
		<para>Illustration of inside-out handling of input.</para>
		<para>The input is shown arrayed along the bottom of
		the diagram:  ovals filled with gray denote start- and
		end-markers, rectangles denote text nodes.  The gray
		ovals above denote the logical hierarchy which is to
		be constructed (visible to human observers even if not
		visible to the software).</para>
	      </caption>
	    </figure>
	    <figure xml:id="visit-IO-1">
	      <mediaobject>
		<imageobject>
		  <imagedata format="png" width="100%" fileref="images/inside-out/Bal2018Birn050541.png"/>
		</imageobject>
	      </mediaobject>
	      <caption>
		<para>On the first pass, the inside-out algorithm
		raises all childless virtual elements.</para>
	      </caption>
	    </figure>
	    <figure xml:id="visit-IO-2">
	      <mediaobject>
		<imageobject>
		  <imagedata format="png" width="100%" fileref="images/inside-out/Bal2018Birn050542.png"/>
		</imageobject>
	      </mediaobject>
	      <caption>
		<para>On the second pass, inside-out raises elements
		with children but no grandchildren.</para>
	      </caption>
	    </figure>
	    <figure xml:id="visit-IO-3">
	      <mediaobject>
		<imageobject>
		  <imagedata format="png" width="90%" fileref="images/inside-out/Bal2018Birn050543.png"/>
		</imageobject>
	      </mediaobject>
	      <caption>
		<para>On the third pass, elements of the third layer
		from the leaves are raised.</para>
	      </caption>
	    </figure>
	    <figure xml:id="visit-IO-4">
	      <mediaobject>
		<imageobject>
		  <imagedata format="png" width="80%" fileref="images/inside-out/Bal2018Birn050544.png"/>
		</imageobject>
	      </mediaobject>
	      <caption>
		<para>The fourth pass raises the children of the
		virtual root.</para>
	      </caption>
	    </figure>
	    <figure xml:id="visit-IO-5">
	      <mediaobject>
		<imageobject>
		  <imagedata format="png" width="70%" fileref="images/inside-out/Bal2018Birn050545.png"/>
		</imageobject>
	      </mediaobject>
	      <caption>
		<para>The fifth pass raises the <code>p</code> element.</para>
	      </caption>
	    </figure>
	    <figure xml:id="visit-IO-end">
	      <mediaobject>
		<imageobject>
		  <imagedata format="png" width="70%" fileref="images/inside-out/Bal2018Birn050546.png"/>
		</imageobject>
	      </mediaobject>
	      <caption>
		<para>In the final state, the inside-out algorithm has
		raised all elements.</para>
	      </caption>
	    </figure>	    
	    
            <section>
                <title>Raising</title>
                
                <para>The output of the preceding transformation is included in the <xref
                        linkend="simplified"/> section, above. We then reconstruct the hierarchy
                    using the inside-out recursive function <code>th:raise()</code> in the following
                XSLT stylesheet:</para>
                
                <figure>
                    <programlisting><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="3.0"
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:th="http://www.blackmesatech.com/2017/nss/trojan-horse"
    exclude-result-prefixes="#all">
    <xsl:output method="xml" indent="no"/>

    <!--* Set $debug parameter to any non-null value to output messages *-->
    <xsl:param name="debug" static="yes" required="no"/>

    <xsl:key name="end-markers" match="*[@th:eID]" use="@th:eID"/>

    <!-- 
        Identity template of anything lower than grandchildren of the root
        Just copy; they cannot contain markers
    -->
    <xsl:template match="/*/*/descendant::node()" mode="#all">
        <xsl:sequence select="."/>
    </xsl:template>

    <!-- Traditional identity template for root and its children -->
    <xsl:template match="@* | node()" mode="#all">
        <xsl:copy copy-namespaces="no">
            <xsl:apply-templates select="@* | node()"/>
        </xsl:copy>
    </xsl:template>

    <!-- 
        th:raise(.):  raise all innermost elements within the document
        messages controlled by $debug stylesheet parameter
    -->
    <xsl:function name="th:raise">
        <xsl:param name="input" as="document-node()"/>
        <xsl:message use-when="$debug">raise() called with 
            <xsl:value-of select="count($input//*)"/>-element document 
            (<xsl:value-of select="count($input//*[@th:sID])"
            /> Trojan pairs)</xsl:message>
        <xsl:choose>
            <xsl:when test="exists($input//*
                           [@th:sID eq following-sibling::*[@th:eID][1]/@th:eID])">
                <!-- If we have more work to do, do it -->
                <xsl:variable name="result" as="document-node()">
                    <xsl:document>
                        <xsl:apply-templates select="$input" mode="loop"/>
                    </xsl:document>
                </xsl:variable>
                <xsl:sequence select="th:raise($result)"/>
            </xsl:when>
            <xsl:otherwise>
                <!-- We have no more work to do, return the input unchanged. -->
                <xsl:message use-when="$debug">raise() returning.</xsl:message>
                <xsl:sequence select="$input"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:function>

    <xsl:template match="/">
        <xsl:sequence select="th:raise(.)"/>
    </xsl:template>

    <xsl:template match="/" mode="loop">
        <xsl:apply-templates/>
    </xsl:template>

    <!--
        Innermost start-markers
        @priority needed here and below because otherwise ambiguous with identity templates
    -->
    <xsl:template match="*[@th:sID eq following-sibling::*[@th:eID][1]/@th:eID]" priority="1">
        <xsl:copy copy-namespaces="no">
            <xsl:copy-of select="@* except @th:sID"/>
            <xsl:variable name="end-marker" as="element()" select="key('end-markers', @th:sID)"/>
            <xsl:copy-of select="following-sibling::node()[. &lt;&lt; $end-marker]"/>
        </xsl:copy>
    </xsl:template>

    <!-- nodes inside new wrapper: suppress, since they have alredy been copied -->
    <xsl:template
        match="node()[preceding-sibling::*[@th:sID][1]/@th:sID eq following-sibling::*[@th:eID][1]/@th:eID]"
        priority="1"/>

    <!-- end-tag for new wrapper; suppress because it has already been copied -->
    <xsl:template match="*[@th:eID eq preceding-sibling::*[@th:sID][1]/@th:sID]" priority="1"/>

</xsl:stylesheet>]]></programlisting>
                    <caption>
                        <para>XSLT to transform Trojan milestones into container elements</para>
                    </caption>
                </figure>
                
                <para>We turn off indentation (line 5) to avoid deforming the whitespace and set up
                    a debug option (line 8), controlled by a
                <code>$debug</code> parameter. </para>
                
                <para>The traditional identity template walks the entire tree, but because any
                    descendant nodes lower than children of the root are guaranteed not to be or
                    contain Trojan markers, we set up one identity template for those lower nodes,
                    which just copied them to the output (lines 16–18). The regular identity
                    template (lines 21–25) applies only to the root element and its children.
                        <code>@exclude-result-prefixes="#all"</code> is not enough to avoid writing
                    the <code>th:</code> namespace onto the root element of the output, even though
                    the namespace in question is not used in the output. An unused namespace
                    declaration is informationally harmless, but also needlessly distracting, so we
                    suppress it by specifying <code>@copy-namespaces="no"</code> on
                        <code>&lt;xsl:copy&gt;</code> in the identity template that deals with
                    Trojan markers (line 22).</para>
                
                <para>Our recursive raising operation (the <code>th:raise()</code> function, lines
                    31–52) operates on document nodes, and we need to process the original document
                    node of the input file differently from the new document nodes that we create on
                    each pass through the recursive function. For that reason, we match the original
                    document node in no mode (<code>&lt;xsl:template match="/"&gt;</code>, lines
                    54–56) and pass it into the raising function (<code>&lt;xsl:sequence
                        select="th:raise(.)"/&gt;</code>, line
                55).</para>
                
                <para>The raising function checks for the presence of <code>@th:sID</code>
                    attributes in the input that are candidates for raising (<code>&lt;xsl:when
                        test="exists($input//*[@th:sID eq
                        following-sibling::*[@th:eID][1]/@th:eID])"&gt;</code>, line 137 see the
                    discussion of this test in <xref linkend="recursion_challenges"/>). If there
                    aren’t any (<code>&lt;xsl:otherwise&gt;</code>, lines 46–50), the recursion is
                    finished, and the function returns the result (<code>&lt;xsl:sequence
                        select="$input"/&gt;</code>, line 49). If there are still
                        <code>@th:sID</code> attributes that can be raised in the text, we create a
                    variable <code>$result</code> (lines 39–43) of type document and apply templates
                    inside the newly created document node (line 41). After the application of
                    templates is finished, we recur and pass the result into another invocation of
                        <code>th:raise()</code> (<code>&lt;xsl:sequence
                        select="th:raise($result)"/></code>, line
                44).</para>
                
                <para>The application of templates within the recursive function begins by applying
                    templates to the (newly created) document node in loop mode
                        (<code>&lt;xsl:apply-templates select="$input" mode="loop"/&gt;</code>, line
                    41). The matching template (lines 58–60) simply applies templates to its
                    children, unlike the template that matches the original document node (in no
                    mode, lines 54–56), which passes the document into the <code>th:raise()</code>
                    function (line 55), a difference in mode that is needed to avoid an endless
                    loop. All other processing is the same for both the original document and the
                    interim documents created inside <code>th:raise()</code>, so
                        <code>&lt;xsl:template match="/" mode="loop"&gt;</code> (lines 58–60) is the
                    only modal template, and it applies templates to
                its children in no mode.</para>
                
                <para>There are three templates that do the actual processing of the innermost
                    elements to be raised on each recursion: one that processes the start-marker,
                    one that processes the content of the newly raised container element, and one
                    that processes the corresponding end-marker. XSLT thinks that they have the same
                    priority as the identity templates, so we specify a higher priority explicitly
                    with <code>priority="1"</code>.<itemizedlist>
                        <listitem>
                            <para><emphasis role="bold">start-marker:</emphasis> We match elements
                                with a <code>@th:sID</code> attribute that has a value equal to the
                                value of a <code>@th:eID</code> attribute on their first following
                                sibling element that has a <code>@th:eID</code> attribute (line 33).
                                This, then, matches only start-markers that contain nothing but
                                    <code>text()</code> nodes, non-Trojan empty elements, and
                                container elements. In other words, it matches only the innermost
                                flattened elements, those that do not contain any other empty
                                flattened elements.<footnote>
                                    <para>Attributes in the <code>th:</code> namespace are removed
                                        from markers when they are converted to tags during
                                        raising.</para>
                                </footnote> We process these hits by creating a container element
                                with the same generic identifier as the start-marker; we instruct it
                                not to copy unused namespaces, and we copy all non-Trojan
                                attributes. We create the element content by copying all
                                following-sibling nodes that precede the end-marker (which we find
                                with the help of the <code>end-markers</code> key) that matches the
                                start-marker we’re processing at the moment (lines 66–72). In other
                                words, we copy the content of the newly raised element into
                                it.</para>
                        </listitem>
                        <listitem>
                            <para><emphasis role="bold">nodes inside the new wrapper:</emphasis> We
                                have already copied the content of the newly raised element inside
                                it, which means that we don’t want to process those nodes again,
                                since that would create duplicates. For that reason, we suppress all
                                nodes between the start- and end-markers that we’re processing at
                                the moment by matching them inside an empty
                                    <code>&lt;xsl:template&gt;</code> element (lines 75–78).</para>
                        </listitem>
                        <listitem>
                            <para><emphasis role="bold">end-marker:</emphasis> Since we create real
                                start- and end-tags when we match the flattened start-marker, we
                                have no more use for the flattened end-marker, so we suppress it by
                                matching it, too, inside an empty <code>&lt;xsl:template&gt;</code>
                                element (line 80).</para>
                        </listitem>
                    </itemizedlist></para>
                
                <para>When the simplified original document is flattened and then raised, as
                    described above, the output of the raising operation matches the original
                input.</para>
                
                </section>
            <section>
                <title>Raising <emphasis>Frankenstein</emphasis></title>
          
                <para>To raise the <emphasis role="ital">Frankenstein</emphasis> data, our process
                    is run recursively over a collection of 165 files in the Frankenstein Variorum.
                    The files have a TEI header that for project maintenance purposes needs to be updated after a version change, and only a portion of the document is to be raised. Here the most significant adaptation is that we supply an element node rather than a document node as the input parameter for the th:raise function. </para>
                
                <figure>
                    <programlisting>
      <![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet
    xpath-default-namespace="http://www.tei-c.org/ns/1.0"
    xmlns="http://www.tei-c.org/ns/1.0"  
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:th="http://www.blackmesatech.com/2017/nss/trojan-horse"
    exclude-result-prefixes="#all"
    version="3.0">
    <xsl:output method="xml" indent="no"/>
    <!--* This stylesheet works to raise "trojan
	elements" from the inside out, this time over a collection
	of Frankenstein files output from collation. It also adapts
	djb's function to process an element node rather than a
	document node in memory to perform its recursive
	processing. *-->
    <xsl:variable name="novel-coll"
        as="document-node()+"
        select="collection('../input/frankenstein/novel-coll/')"/>    
     
    <!--* In all modes, do a shallow copy, suppress namespace nodes,
	* and recur in default (unnamed) mode. *-->
    <xsl:template match="@* | node()" mode="#all">
      <xsl:copy copy-namespaces="no">
            <xsl:apply-templates select="@* | node()"/>
        </xsl:copy>
    </xsl:template>

    <!--* th:raise(.):  raise all innermost elements within the container element this time passed as parameter *-->
   <xsl:function name="th:raise">
       <xsl:param name="input" as="element()"/>
       <xsl:choose>
           <xsl:when test="exists($input//*[@th:sID eq following-sibling::*[@th:eID][1]/@th:eID])">
               <xsl:variable name="result" as="element()">
                   <div type="collation">
                       <xsl:apply-templates select="$input" mode="loop"/>                            
                   </div>
               </xsl:variable>
               <xsl:sequence select="th:raise($result)"/>
           </xsl:when>
           <xsl:otherwise>
               <!--* We have no more work to do, return the input unchanged. *-->
               <xsl:message>raise() returning.</xsl:message>
               <xsl:sequence select="$input"/>
           </xsl:otherwise>
       </xsl:choose>
   </xsl:function>
   
   <xsl:template match="/">
       <xsl:for-each select="$novel-coll//TEI">
           <xsl:variable name="filename">              
               <xsl:text>raised_</xsl:text><xsl:value-of select="tokenize(base-uri(), '/')[last()]"/>
           </xsl:variable>
           <xsl:variable name="chunk"
			 as="xs:string"
			 select="substring-before(tokenize(base-uri(), '/')[last()], '.') ! substring-before(., '_')"/> 
           <xsl:result-document method="xml"
				indent="yes"
				href="output/frankenstein/novel-coll/{$filename}">
               <TEI>
		   <xsl:apply-templates select="descendant::teiHeader"/>
		   <text>
		       <body>
			   <xsl:apply-templates select="descendant::div[@type='collation']"/>
		       </body>
		   </text>
               </TEI>
           </xsl:result-document>
       </xsl:for-each>  
   </xsl:template>
<!--* Template rules for altering the TEI header, otherwise uninvolved in the raising process: *-->   
   <xsl:template match="teiHeader">
       <teiHeader>
           <fileDesc>
               <titleStmt><xsl:apply-templates select="descendant::titleStmt/title"/></titleStmt>
               <xsl:copy-of select="descendant::publicationStmt" copy-namespaces="no"/>
               <xsl:copy-of select="descendant::sourceDesc" copy-namespaces="no"/>
	   </fileDesc>
       </teiHeader>
   </xsl:template>  
   <xsl:template match="titleStmt/title">
       <title>
           <xsl:text>Bridge Phase 4:</xsl:text><xsl:value-of select="tokenize(., ':')[last()]"/>
       </title>
   </xsl:template>
    
    <!--* On the input container element node, call th:raise() *-->
   <xsl:template match="div[@type='collation']">
       <xsl:sequence select="th:raise(.)"/>
   </xsl:template>
    <!--* Loop mode (applies to container element only). *-->
    <!--* Loop mode for container element:  just apply templates in default unnamed mode. *-->  
   <xsl:template match="div[@type='collation']" mode="loop">
       <xsl:apply-templates/>
   </xsl:template>  
    <xsl:template match="*[@th:sID eq
        following-sibling::*[@th:eID][1]/@th:eID]">
       <xsl:variable name="currNode" select="current()" as="element()"/>
       <xsl:variable name="currMarker" select="@th:sID" as="xs:string"/>
       <xsl:element name="{name()}">
           <xsl:copy-of select="@* except @th:sID"/>
           <xsl:attribute name="xml:id">
               <xsl:value-of select="@th:sID"/>
           </xsl:attribute>
           <xsl:variable name="end-marker" as="element()" select="following-sibling::*[@th:eID = current()/@th:sID]"/>
           <xsl:copy-of select="following-sibling::node()[. &lt;&lt; $end-marker]"/>
       </xsl:element>
   </xsl:template>

   <!--suppressing nodes that are being reconstructed, including the old end marker. -->
    <xsl:template
        match="node()[preceding-sibling::*[@th:sID][1]/@th:sID eq following-sibling::*[@th:eID][1]/@th:eID]"/>
   
    <xsl:template match="*[@th:eID eq preceding-sibling::*[@th:sID][1]/@th:sID]"/>
        </xsl:stylesheet>]]>
                    </programlisting>
                    <caption><para>Inside-out raising of the Frankenstein Variorum collection</para></caption>
                </figure>
                <para>The adaptation to the raising function to process a container element node allows for us to make changes to our TEI header. Beyond this, there are few differences between our
                    generic inside-out raising example and the <emphasis>Frankenstein</emphasis>
                    stylesheet. One minor difference is that we use only one identity-transformation template, and have not set a priority on the template rule to process the innermost elements. We convert the Trojan marker attributes into an xml:id with an element constructor:</para>
                
                <figure>
                    <programlisting>&lt;xsl:element name="{name()}"&gt;
    &lt;xsl:attribute name="xml:id" select="@th:sID"/&gt;
    &lt;xsl:copy-of
        select="following-sibling::node()[following-sibling::*[@th:eID eq current()/@th:sID]]"/&gt;
&lt;/xsl:element&gt;</programlisting>
                    <caption>
                        <para>Element constructor to refactor <code>@th:sID</code> as
                                <code>@xml:sid</code> in <emphasis role="ital"
                                >Frankenstein</emphasis></para>
                    </caption>
                </figure>
                
            </section>
            
          <!--2018-07-23 ebb: THIS SECTION TBD:
              <section>
                <title>XSLT 1.0</title>
                <para>
                    <emphasis role="ital">At the time of submission, no XSLT 1.0 version is
                        available.</emphasis>
                </para>
            </section>-->
            
          </section>

	  <section xml:id="outside-in">
	    <title>Outside-in processing</title>
	    <para>Once the inside-out algorithm has been defined and
	    understood, it is natural to wonder whether a mirror-image
	    version of the algorithm would be possible which works
	    from the outside in.  Once the pairs of outermost start-
	    and end-markers have been identified, the function can be
	    called recursively not on the entire document but only on
	    the children of the outermost elements, in an
	    instantiation of a divide-and-conquer strategy; this
	    should (or so it seems) result in faster processing.
	    </para>
	    <para>Our realization of this idea is imperfect
	    in that we have not found a way to find and raise
	    <emphasis role="ital">all</emphasis> outermost
	    elements in a sequence with a single call, the way
	    the template-matching rules of the inside-out 
	    approach can raise multiple elements in a single
	    call to <code>apply-templates</code>.  Instead,
	    we find the left-most start-marker and process it,
	    then recur to continue processing the remainder
	    of the sequence after the matching end-marker.
	    This results in two recursive calls for each virtual
	    element:  one to handle the children of the newly
	    raised element, and one for its right-siblings.</para>

	    <para>The order in which elements are raised
	    is illustrated in the diagrams of
	    <xref linkend="visit-OI-start"/>
	    to 
	    <xref linkend="visit-OI-end"/>.
	    Some steps are elided to save space.
	    </para>
	    
	    <figure xml:id="visit-OI-start">
	      <mediaobject>
		<imageobject>
		  <imagedata format="png" width="100%" fileref="images/outside-in/Bal2018Birn050560.png"/>
		</imageobject>
	      </mediaobject>
	      <caption>
		<para>Illustration of outside-in handling of input.</para>
		<para>The input is shown arrayed along the bottom of
		the diagram:  ovals filled with gray denote start- and
		end-markers, rectangles denote text nodes.  The gray
		ovals above denote the logical hierarchy which is to
		be constructed (visible to human observers even if not
		visible to the software).</para>
	      </caption>
	    </figure>
	    <figure xml:id="visit-OI-1">
	      <mediaobject>
		<imageobject>
		  <imagedata format="png" width="100%" fileref="images/outside-in/Bal2018Birn050561.png"/>
		</imageobject>
	      </mediaobject>
	      <caption>
		<para>On the first pass, the outside-in algorithm
		raises the leftmost outer element, here the paragraph.</para>
	      </caption>
	    </figure>
	    <figure xml:id="visit-OI-2">
	      <mediaobject>
		<imageobject>
		  <imagedata format="png" width="100%" fileref="images/outside-in/Bal2018Birn050562.png"/>
		</imageobject>
	      </mediaobject>
	      <caption>
		<para>On the first recursive call, outside-in raises elements
		the citation (<code>cit</code>) element.</para>
	      </caption>
	    </figure>
	    <figure xml:id="visit-OI-3">
	      <mediaobject>
		<imageobject>
		  <imagedata format="png" width="90%" fileref="images/outside-in/Bal2018Birn050563.png"/>
		</imageobject>
	      </mediaobject>
	      <caption>
		<para>On the third call, an ideal outside-in algorithm
		would raise both the <code>quote</code> element
		and the <code>note</code>, but our implementation
		raises just the leftmost of these.</para>
	      </caption>
	    </figure>
	    <figure xml:id="visit-OI-4">
	      <mediaobject>
		<imageobject>
		  <imagedata format="png" width="80%" fileref="images/outside-in/Bal2018Birn050564.png"/>
		</imageobject>
	      </mediaobject>
	      <caption>
		<para>The fourth call to outside-in continues the
		depth-first traversal of the virtual tree.</para>
	      </caption>
	    </figure>
	    <!--*
	    <figure xml:id="visit-OI-5">
	      <mediaobject>
		<imageobject>
		  <imagedata format="png" width="70%" fileref="images/outside-in/Bal2018Birn050565.png"/>
		</imageobject>
	      </mediaobject>
	      <caption>
		<para>The fifth call raises the first verse line.</para>
	      </caption>
	    </figure>
	    <figure xml:id="visit-OI-6">
	      <mediaobject>
		<imageobject>
		  <imagedata format="png" width="70%" fileref="images/outside-in/Bal2018Birn050566.png"/>
		</imageobject>
	      </mediaobject>
	      <caption>
		<para>The sixth call raises the second verse line.</para>
	      </caption>
	    </figure>
	    <figure xml:id="visit-OI-7">
	      <mediaobject>
		<imageobject>
		  <imagedata format="png" width="70%" fileref="images/outside-in/Bal2018Birn050567.png"/>
		</imageobject>
	      </mediaobject>
	      <caption>
		<para>The seventh call raises the third verse line.</para>
	      </caption>
	    </figure>
	    <figure xml:id="visit-OI-8">
	      <mediaobject>
		<imageobject>
		  <imagedata format="png" width="70%" fileref="images/outside-in/Bal2018Birn050568.png"/>
		</imageobject>
	      </mediaobject>
	      <caption>
		<para>The eighth call raises the fourth verse line.</para>
	      </caption>
	    </figure>
	    <figure xml:id="visit-OI-9">
	      <mediaobject>
		<imageobject>
		  <imagedata format="png" width="70%" fileref="images/outside-in/Bal2018Birn050569.png"/>
		</imageobject>
	      </mediaobject>
	      <caption>
		<para>The ninth call raises the fifth verse line.</para>
	      </caption>
	    </figure>
	    *-->
	    <figure xml:id="visit-OI-10">
	      <mediaobject>
		<imageobject>
		  <imagedata format="png" width="70%" fileref="images/outside-in/Bal2018Birn050570.png"/>
		</imageobject>
	      </mediaobject>
	      <caption>
		<para>The tenth call to the outside-in function raises the sixth and final verse line.</para>
	      </caption>
	    </figure>
	    <figure xml:id="visit-OI-11">
	      <mediaobject>
		<imageobject>
		  <imagedata format="png" width="70%" fileref="images/outside-in/Bal2018Birn050571.png"/>
		</imageobject>
	      </mediaobject>
	      <caption>
		<para>On the eleventh call, we reach the <code>note</code> element.</para>
	      </caption>
	    </figure>
	    <figure xml:id="visit-OI-12">
	      <mediaobject>
		<imageobject>
		  <imagedata format="png" width="70%" fileref="images/outside-in/Bal2018Birn050572.png"/>
		</imageobject>
	      </mediaobject>
	      <caption>
		<para>The final pass raises the <code>bibl</code> element.</para>
	      </caption>
	    </figure>
	    <figure xml:id="visit-OI-end">
	      <mediaobject>
		<imageobject>
		  <imagedata format="png" width="70%" fileref="images/outside-in/Bal2018Birn050573.png"/>
		</imageobject>
	      </mediaobject>
	      <caption>
		<para>In the final state, the outside-in algorithm has
		raised all elements.</para>
	      </caption>
	    </figure>	    
	    


	    <section>
	      <title>Code outline</title>
	    
	      <para>The default handling for all nodes is
	      a shallow copy, as specified in the mode
	      declaration for the default mode:</para>
	      <figure>
		<programlisting><![CDATA[<xsl:mode on-no-match="shallow-copy"/>]]></programlisting>
	      </figure>
	      
	      <para>For content nodes, the function <code>th:raise-sequence()</code> is called on their
                    children. In the simple inputs we are dealing with, this template will match
                    only the document's outermost element; for the Frankenstein data, it will match
                    several others. At the time of this writing, we have not experimented to see
                    whether it would be faster to test for start- and end-marker children here. </para>
	      <figure>
		<programlisting><![CDATA[<xsl:template match="*[exists(node())]">
  <xsl:copy>
    <xsl:sequence 
      select="@*,
             th:raise-sequence(child::node())"/>
  </xsl:copy>
</xsl:template>]]></programlisting>
	      </figure>
	      
	      <para>The core of the implementation is the
	      <code>th:raise-sequence</code> function.</para>
	      <para>The function begins by creating lists of start- and end-markers (identified by their
                    co-indexing IDs), so that we can find not just the leftmost start-marker but the
                    leftmost start-marker <emphasis role="ital">with a matching end-marker in the
                        sequence</emphasis>. If there are no matching pairs in the sequence, the
                    sequence is returned without change. (This makes this implementation slightly
                    more robust in the presence of overlap than the implementation shown above of
                    the right-sibling traversal approach; we have not yet had time to update our
                    method of right-sibling traversal to rectify the inconsistency in implementation
                    philosophy.)</para>
	      <para>In the normal case, however, the function
	      will select the leftmost start-marker with a
	      matching end-marker, find the positions of the
	      start- and end-markers in the input, and then
	      partition the input sequence into three parts.
	      A call to <code>apply-templates</code> processes
	      nodes preceding the selected start-marker;
	      a recursive call to <code>th:raise-sequence()</code>
	      from within the raised elements processes the
	      nodes between the selected start- and end-markers;
	      a second recursive call processes the remainder
	      of the original sequence.</para>
	      
	      <figure>
		<programlisting><![CDATA[<xsl:function name="th:raise-sequence" as="node()*">
    <xsl:param name="ln" as="node()*"/>

    <!--* lidStarts, lidEnds:  lists of IDs
        * for start- and end-markers *-->
    
    <xsl:variable name="lidStarts"
      as="xs:string*"
      select="for $n in $ln[th:start-marker(.)]
        return th:id($n)"/>
    <xsl:variable name="lidEnds"
      as="xs:string*"
      select="for $n in $ln[th:end-marker(.)]
        return th:id($n)"/>
    
    <xsl:choose>
      <!--* base case:  no start-marker / end-marker
          * pairs present *-->
      <xsl:when test="empty($lidStarts[. = $lidEnds])">
        <!--* The sequence may contain elements 
            * with markers inside, so we apply 
            * templates, instead of just returning $ln *-->
        <xsl:apply-templates select="$ln"/>
      </xsl:when>

      <!--* 'normal' case: take first start-marker 
          * with matching end-marker *-->
      <xsl:otherwise>
        <!--* find ID of first start-marker
           * with matching end-marker *-->
         <xsl:variable name="id"
           as="xs:string"
           select="$lidStarts[. = $lidEnds][1]"/>
        <!--* find position of start- and
            * end-markers with that ID *-->
        <xsl:variable name="posStartEnd"
          as="xs:integer+"
          select="for $i in 1 to count($ln) return
                      if ($ln[$i]
                          [(th:start-marker(.) 
                          or th:end-marker(.)) 
                          and th:id(.) eq $id])
                          then $i else ()"/>
                          
        <xsl:variable name="posStart" 
          as="xs:integer"
          select="$posStartEnd[1]"/>
        <xsl:variable name="posEnd" 
          as="xs:integer"
          select="$posStartEnd[2]"/>

        <!--* Apply templates to all items to 
            * left of start. These may include
            * markers, but if so they are not 
            * matched and not raisable. They 
            * may also include elements which
            * contain markers, so we need to apply
            * templates, not just return them.
            *-->
            
        <xsl:apply-templates
          select="$ln[position() lt $posStart]"/>
        
        <!--* Raise the element and 
            * call raise-sequence() on its
            * content. *-->
        <xsl:copy select="$ln[$posStart]">
          <!--* copy the attributes
              * (filtering as needed) *-->
          <xsl:sequence 
            select="$ln[$posStart]/(@* except @th:*)"/>

          <!--* handle children *-->      
          <xsl:sequence 
            select="th:raise-sequence(
                   $ln[position() gt $posStart 
                       and position() lt $posEnd])"/>    
        </xsl:copy>
        
        <!--* call raise-sequence() on all items 
            * to right of end *-->
        <xsl:sequence
          select="th:raise-sequence(
                 $ln[position() gt $posEnd]
                 )"/>
      </xsl:otherwise>
    </xsl:choose>
</xsl:function>]]></programlisting>
	      </figure>
	      
	      <para>A number of ancillary functions are 
	      defined in the stylesheet and used in the
	      code shown above.  They are shown
	      briefly here.  <!--* Why?  Who cares?! *-->
	      <!--* Well, because we show this kind of
		  thing elsewhere, and inconsistency
		  will confuse the reader.   Yes, it's verbose
		  and unnecessary.  But suck it up, MIchael.
		  It's just a paper. *-->
	      </para>
	      <para>The <code>th:start-marker()</code>
	      and <code>th:end-marker()</code> functions
	      encapsulate the recognition criteria for
	      markers.  (These forms are redundant with
	      those given elsewhere in this paper; we have
	      not yet eliminated the redundancy in our
	      demonstration code.)</para>
	      <figure>
		<programlisting><![CDATA[  <xsl:function name="th:start-marker" as="xs:boolean">
    <xsl:param name="e" as="node()"/>
    
    <xsl:value-of use-when="$th-style = 'th' "
	select="exists($e/@th:sID)"/>
    <xsl:value-of use-when="$th-style = 'xmlid' "
	select="ends-with($e/@xml:id,'_start')"/>
    
  </xsl:function>
  
  <xsl:function name="th:end-marker" as="xs:boolean">
    <xsl:param name="e" as="node()"/>
    
    <xsl:value-of use-when="$th-style = 'th' "
	select="exists($e/@th:eID)"/>
    <xsl:value-of use-when="$th-style = 'xmlid' "
		  select="ends-with($e/@xml:id,'_end')"/>
    
  </xsl:function>
  ]]></programlisting>
	      </figure>
	      
	      <para>The <code>th:id()</code> function
	      returns the co-indexing identifier used for
	      any given marker.</para>
	      <figure>
		<programlisting><![CDATA[<xsl:function name="th:id" as="xs:string?">
    <xsl:param name="e" as="node()"/>
    
    <xsl:value-of use-when="$th-style = 'th' "
	select="($e/@th:sID, $e/@th:eID)"/>
    <xsl:value-of use-when="$th-style = 'xmlid' "
		  select="replace($e/@xml:id,'(_start|_end)$','')"/>
    
</xsl:function>]]></programlisting>
	      </figure>
	    </section>
	    
	    <section>
	      <title>Resource consumption</title>
	      <para>
		The implementation shown calls the
		<code>th:raise-sequence()</code> function
		once for each virtual element.  The cost of
		the process should thus be roughly linear
		in the number of virtual elements in the input;
		that seems consistent with our timings of
		XSLT processors.<footnote>
		<para>
		  In an experimental implementation of
		  inside-out and outside-in using tumbling
		  windows in XQuery, on the other hand, the
		  two approaches differ dramatically in run
		  time, and the costs do not appear to be
		  linear.  We do not currently have good
		  data on this or any explanation.
		</para>
	      </footnote>
	      </para>
	      <para>Each node in the original flattened sequence is
	      passed to the central as part of the argument sequence
	      once for each level of its distance from the root of the
	      virtual tree.  In this, the outside-in approach is
	      indeed the mirror image of the inside-out approach.
	      </para>
	      <para>The implementation of outside-in shown here is not, however, demonstrably faster than
                    our implementation of inside-out, despite the divide-and-conquer strategy. We
                    have not been able to perform measurements to explain the differences in run
                    time, but we can offer a couple of speculations. First, on our test data the
                    inside-out approach reduces the number of nodes faster than the outside-in
                    approach: in a typical XML tree there will be more leaf nodes than root nodes
                    (and more than that: in our test data the fanout increases with distance from
                    the root). Second, each call to the function traverses the input sequence
                    several times: once to find all start-marker IDs, once to find all end-marker
                    IDs, once to find the positions of the selected markers. Either or both of these
                    could explain a slow run-time. </para>
	      <!--* need plot of run times for HE, Exselt *-->
	      <!--* need plots of run times for 1.0 version for  HE, 
		  Exselt, xsltproc *-->
	      <!--* need plots to compare run times for i/o and o/i
		  for HE, Exselt, xsltproc *-->
	    </section>
	  </section>
	  
        <section xml:id="accumulators" xreflabel="Accumulators">
            <title>Accumulators</title>
            
            <para>Another approach to the problem avoids recursion by performing a single pass over
                the input, maintaining a stack of partly-raised elements using the
                    <emphasis>accumulator</emphasis> construction
            introduced in XSLT 3.0.</para>

	    <section>
	      <title>A bluffer's guide to accumulators</title>
            <para>An accumulator is a sequence of values associated with the nodes of a tree. Each
                    node has two values: <orderedlist>
                        <listitem><para>a <emphasis>before</emphasis> value (calculated without
                    access to the values associated with any descendants, and thus calculable before
                    descendants are visited in a depth-first traversal of the tree)</para></listitem> 
                        <listitem><para>an <emphasis>after</emphasis> value (which may depend on the values associated
                    with descendants and thus cannot be calculated until after they have been
                    visited).</para></listitem></orderedlist> 
                The declaration of an accumulator specifies how to calculate the
                    <emphasis>before</emphasis> and after values to be associated with a node, given the <emphasis>after</emphasis> values
                    associated with the previous node and with the node’s last child. One simple way
                    to calculate all the values of an accumulator would be to visit each node in the
                    document in a pre-and-post-order traversal, determining the <emphasis>before</emphasis> value on the
                    first visit to a node and the <emphasis>after</emphasis> value on the second. When streaming
                    processing is requested, the calculation rules are not allowed to look ahead in
                    the document, but accumulators can be used whether or not streaming is
                    requested.</para>
            
            <para>As a simple example, we can make an accumulator to keep track of the number of
                open virtual elements at any given point in the flattened input document: when we
                encounter a start-marker we will add one to the accumulated value, and when we
                encounter an end-marker we will subtract one. An accumulator is declared using an
                    <code>&lt;xsl:accumulator&gt;</code> declaration, which contains a sequence of
                    <code>&lt;xsl:accumulator-rule&gt;</code> elements describing how the
                accumulator’s values are calculated. Within an accumulator rule, the variable
                    <code>$value</code> gives the value of the accumulator assigned by the
            immediately preceding node.</para>
            
            <figure>
                <programlisting><![CDATA[<xsl:accumulator name="level" as="xs:integer"
                   initial-value="0"
                   streamable="yes" >
    <xsl:accumulator-rule match="*[@th:sID]"
                          select="$value + 1"/>
    <xsl:accumulator-rule match="*[@th:eID]"
                          select="$value - 1"/>
</xsl:accumulator>]]></programlisting>
                <para>The declaration for a simple accumulator</para>
            </figure>
            
            <para>The pattern in the accumulator rules here assumes that start- and end-markers use
                the <code>@th:sID</code> and <code>@th:eID</code>
            attributes described above.</para>
            
            <para>At any point in a tree to which this accumulator applies, we can refer to the
                current node’s <emphasis>before</emphasis> value of the accumulator with the expression
                    <code>accumulator-before('stack')</code> and to the <emphasis>after</emphasis> value with
                    <code>accumulator-after('stack')</code>.<footnote>
                    <para>In streaming processing, references to the <emphasis>after</emphasis> value can only be located
                        after any <code>&lt;xsl:apply-templates&gt;</code> or other expression that
                        requires that descendants be processed.</para>
                </footnote> Without accumulators, we could keep track of the relevant information by
                replacing references to <code>accumlator-before('stack')</code> with references to
                    <code>count(preceding::*[@th:sID]) -
            count(preceding::[@th:eID])</code>.</para>
	    </section>
	    
	    <section>
	      <title>Implementation strategy</title>
            
            <para>To solve the raising problem with accumulators, we declare an accumulator whose
                value is an array (if the XPath 3.1 feature is supported) or a map, with which we
                maintain a stack of virtual elements that have been started, but not finished. The
                first member of the array will track the contents of the outermost element, the
                second member will track the contents of a second-level virtual element, and so
                forth. Each member of the array is a sequence of nodes containing a start marker
                (the first item in the sequence) and all the nodes seen so far that should be
            children of the raised content element.</para>
            
            <para>The processing rules are relatively straightforward and may feel familiar to
                anyone who has ever constructed an in-memory tree from a SAX event stream: <itemizedlist>
                    <listitem>
                        <para>Each time we see a start-marker, we will push a new sequence onto the
                            stack.</para>
                    </listitem>
                    <listitem>
                        <para>Each time we see a text node, comment, processing instruction, or
                            content element, we will append it to the sequence on the top of the
                            stack.</para>
                    </listitem>
                    <listitem>
                        <para>Each time we see an end-marker, we will</para>
                        <itemizedlist>
                            <listitem>
                                <para>Create a content element from the sequence on top of the
                                    stack: the element type and attributes come from the
                                    start-marker at <code>$stack(array:size($stack))[1]</code>, and
                                    the contents come from the rest of the sequence:
                                        <code>$stack(array:size($stack))[position() gt
                                    1]</code>.</para>
                            </listitem>
                            <listitem>
                                <para>Pop the stack, i.e., discard the topmost member, whose purpose
                                    has been served now it has been turned into a content
                                    element.</para>
                            </listitem>
                            <listitem>
                                <para>Append the newly created content element to the sequence now
                                    at the top of the stack.</para>
                            </listitem>
                        </itemizedlist>
                        <para>Special handling is required for the case in which the element just
                            ending is at level 1 in the stack, because once the stack has been
                            popped there is no top level to which to append the new element, which
                            should be written to the output tree instead.</para>
                    </listitem>
            </itemizedlist></para>
            </section>
            <section>
                <title>Some utility functions</title>
                <para>In order to allow the stylesheet to be used with either the <code>th:</code>
                    attributes or with the <code>ana="start|end"</code> convention, we isolate the
                    definition of start- and end-markers in two functions we place in the
                    Trojan-Horse namespace:</para>
                <figure>
                    <programlisting><![CDATA[<!--* th:trojan-start($e as element()):  true iff $e is a Trojan
    * start-tag we want to process.
    *-->
<xsl:function name="th:trojan-start" as="xs:boolean">
    <xsl:param name="e" as="element()"/>
    
    <xsl:value-of use-when="$th-style = 'th' "
        select="exists($e/@th:sID)"/>
    <xsl:value-of use-when="$th-style = 'xmlid' "
        select="ends-with($e/@xml:id,'_start')"/>
    
 </xsl:function>
  
<!--* th:trojan-end($e as element()):  true iff $e is a Trojan
    * end-tag we want to process.
    *-->
<xsl:function name="th:trojan-end" as="xs:boolean">
    <xsl:param name="e" as="element()"/>
    
    <xsl:value-of use-when="$th-style = 'th' "
        select="exists($e/@th:eID)"/>
    <xsl:value-of use-when="$th-style = 'xmlid' "
                  select="ends-with($e/@xml:id,'_end')"/>
    
</xsl:function>]]></programlisting>
                    <para>Two functions to encapsulate the definition of markers</para>
                </figure>
                <para>These functions rely on a static parameter that identifies the idiom in use
                    for markers.</para>
                <figure>
                    <programlisting><![CDATA[<xsl:param name="th-style" select=" 'ana' " static="yes"/>]]></programlisting>
                    <para>A static parameter to control the definition of markers</para>
                </figure>
                <para>Marking the parameter as static allows the choice among definitions to be made
                    during static analysis of the stylesheet (informally, at compile time) and not
                    with a dynamic (run-time) <code>choose/when</code> construction.</para>
                <para>Another function constructs a content element from a sequence of nodes
                    beginning with a start-marker:</para>
                <figure>
                    <programlisting><![CDATA[<!--* th:make-element($ln as node()+):  make an element out of
    * one stack entry *-->
<!--* We package this as a function because it's called from
    * two different locations in the stylesheet *-->
<xsl:function name="th:make-element" as="element()">
    <xsl:param name="ln" as="node()+"/>
    
    <xsl:copy select="$ln[1]">
      <!--* first copy (and filter) attributes *-->
      <xsl:sequence select="$ln[1]/(@* except @th:*)"
                    use-when="$th-style = 'th' "/>  
      <xsl:sequence use-when="$th-style='xmlid'">
        <xsl:sequence select="$ln[1]/@*"/>
        <xsl:attribute name="xml:id" 
            select="replace($ln[1]/@xml:id, '_start$','')"/>
      </xsl:sequence>
      
      <!--* then copy children *-->
      <xsl:sequence select="$ln[position() gt 1]"/>
    </xsl:copy>
    
</xsl:function>]]></programlisting>
                    <para>A function to construct a content element from a start marker and sequence
                        of nodes</para>
                </figure>
                <para>
                    <emphasis>The functions just presented are not specific to the use of
                        accumulators; they or analogous functions could be used in any of the XSLT
                        stylesheets described here. But most of the other code shown in the current
                        version of this paper does not use them; they are described here because the
                        other code in this section uses them and would be hard to understand if they
                        were not presented.</emphasis>
                </para>
            </section>
            
            <section>
                <title>Declaring the accumulator and making it applicable</title>
                <para>The overall pattern of accumulator declarations was shown above, and the
                    declaration for an accumulator to be used as a stack follows the same pattern,
                    though the rules are slightly more complex.</para>
                <figure>
                    <programlisting><![CDATA[<!--* Declare stack accumulator to keep track of contents. *-->
<!--* Start with empty array. *-->
<xsl:accumulator name="stack" as="array(node()*)"
               initial-value="[]"
               streamable="yes"
               >
<!--* On Trojan start-tag, push the start-tag onto the stack *-->
<xsl:accumulator-rule match="*[th:trojan-start(.)]"
                      select="array:append($value, .)"/>

<!--* On Trojan end-tag, make the currently pending element,
    pop the stack, and insert the pending element at the
    end of the new top item. *-->
<xsl:accumulator-rule match="*[th:trojan-end(.)]"                     
                      phase="end">
  
  <xsl:variable name="level" as="xs:integer"
                select="array:size($value)"/>
  <xsl:variable name="e" as="element()"
                select="th:make-element($value($level))"/>
  <xsl:choose>
    <xsl:when test="$level eq 1">
      <!--* at outermost level, we have no previous
          level to add anything to, so we just pop the
          stack. *-->
      <xsl:sequence select="[]"/>
    </xsl:when>
    <xsl:otherwise>   
      <xsl:sequence select="array:put(
                            array:remove($value, $level),
                            $level - 1,
                            ($value($level - 1), $e))"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:accumulator-rule>

<!--* On any other node, append current node
    * to the top sequence in the stack *-->
<xsl:accumulator-rule
    match="node()[not(self::element())
            or (not(th:trojan-start(.)) 
            and not(th:trojan-end(.)))]"
    select="for $level in array:size($value) return
            if ($level eq 0)
            then []
            else array:put(
                 $value,
                 $level,
                 ($value($level), .))"/>
</xsl:accumulator>]]></programlisting>
                    <para>Declaration of an accumulator to be used as a stack</para>
                </figure>
                <para>Since accumulators were introduced largely to support the streaming processing
                    of very large inputs, and since the pointless calculation of accumulator values
                    would make that processing unnecessarily difficult, XSLT 3.0 requires that any
                    accumulators be associated more or less explicitly with an input tree or a mode.
                    If the accumulator is not made applicable to a given tree in this way,
                    references to the <code>accumulator-before()</code> and
                        <code>accumulator-after()</code> functions will raise errors.
                    <!--* Dont ask why I know this and find it worth
              mentioning. *-->
                    We handle that by declaring the default mode of the stylesheet and adding a
                        <code>@use-accumulators</code> attribute naming the accumulators to be
                    calculated:</para>
                <figure>
                    <programlisting><![CDATA[<!--* declare default mode; we make it fail on no match
  * because it turns out we need templates for all nodes.
  *-->
<xsl:mode on-no-match="fail"
        use-accumulators="stack"
        streamable="yes"/>]]></programlisting>
                    <para>Declaration of mode with <code>@use-accumulators</code></para>
                </figure>
                <para>Note that the <code>streamable="yes"</code> is not required unless streaming
                    processing is to be requested.<footnote>
                        <para>Despite Saxon’s apparent belief to the contrary, the declarative
                            statement that the accumulator is streamable does not constitute a
                            request that the XSLT processor perform streaming processing of the
                            input. It is merely a claim that streaming processing is possible.
                            <!--* Are you listening to me, Mike?  Mike?  Mik- oh,
              forget it, no, he never listens to me on this.
              Sigh. *--></para>
                    </footnote></para>
</section>

            <section>
                <title>Templates</title>
                <para>The templates in this stylesheet have very little work to do: their primary
                    task is to override the default templates and ensure that nodes are not copied
                    unnecessarily to the output tree.</para>
                <para>The template for start-markers does nothing; all the work is handled by the
                    declaration of the accumulator.</para>
                <!--* 2018-07-24 ebb: ??? Why have you set priority="10" on the template rules matching trojan start and end markers below?  -->
                <figure>
                    <programlisting><![CDATA[<!--************************************************
  * 1.  Virtual start-tags 
  ************************************************-->
<xsl:template match="*[th:trojan-start(.)]" priority="10">
<!--* Nothing to do, all the work 
    * is done by the accumulator *-->
</xsl:template>]]></programlisting>
                    <para>Template for start-markers</para>
                </figure>
                <para>The template for end-markers is more complicated, because it must handle the
                    case where the end-marker marks the end of an outermost virtual element. The
                    normal accumulator rules cannot handle this case, because they write the newly
                    constructed element into the new top member of the stack. But after we pop the
                    stack at level one, the stack is empty and there is no top member. So we need to
                    make the element and write it to the output tree ourselves. In all other cases,
                    this template has no work to do.</para>
                <figure>
                    <programlisting><![CDATA[<!--************************************************
  * 2.  Virtual end-tags 
  ************************************************-->  
<xsl:template match="*[th:trojan-end(.)]" priority="10">
<xsl:choose>
  <xsl:when
      test="array:size(accumulator-before('stack')) eq 1">  
    <!--* if this end-tag ends the outermost element,
        * emit the element *-->
    <xsl:sequence
      select="th:make-element(accumulator-before('stack')(1))"/>                
  </xsl:when>
  <xsl:otherwise>
    <!--* Otherwise, nothing to do *-->
  </xsl:otherwise>
</xsl:choose>
</xsl:template>]]></programlisting>
                    <para>Template for end-markers</para>
                </figure>
                <para>The template for the document node is identical to the default template; it is
                    made necessary by the specification <code>on-no-match="fail"</code> on the mode
                    declaration.</para>
                <figure>
                    <programlisting><![CDATA[<!--************************************************
  * 3.  All other nodes 
  ************************************************-->
<!--* 3.1 Document node *-->
<xsl:template match="/">
<xsl:apply-templates/>
</xsl:template>]]></programlisting>
                    <para>Template for document node</para>
                </figure>
                <para>The templates for other nodes make the same distinction as that for
                    end-markers: when the stack is empty, the node is copied to the output tree, and
                    otherwise all the work is left to the accumulator.</para>
                <figure>
                    <programlisting><![CDATA[<!--* 3.2 Non-marker element nodes *-->
<xsl:template match="node()[self::element()
                   and not(th:trojan-start(.))
                   and not(th:trojan-end(.)) ]">
<!--* If we are outside the flattened area, copy the node;
    * otherwise, do nothing and leave everything 
    * to the accumulator *-->
<xsl:choose>
  <xsl:when 
      test="array:size(accumulator-before('stack')) eq 0">
    <xsl:copy>
      <xsl:copy-of select="@*"/>
      <xsl:apply-templates/>
    </xsl:copy>
  </xsl:when>
  <xsl:otherwise/>
</xsl:choose>    
</xsl:template>]]></programlisting>
                    <para>Template for content elements (or non-selected markers)</para>
                </figure>
                <figure>
                    <programlisting><![CDATA[<!--* 3.3 Non-element nodes *-->
<xsl:template match="node()[not(self::element())]">
<!--* If we are outside the flattened area, copy the node;
    * otherwise, do nothing and leave everything 
    * to the accumulator *-->
<xsl:choose>
  <xsl:when
      test="array:size(accumulator-before('stack')) eq 0">
    <xsl:sequence select="."/>
  </xsl:when>
  <xsl:otherwise/>
</xsl:choose>    
</xsl:template>]]></programlisting>
                    <para>Template for non-element nodes</para>
                </figure>
                <!--* ??? ebb: This section could use a little more concluding discussion: how does the accumulator perform by comparison with the other methods we've been exploring? 
                    Is it faster/more efficient/less error-prone?  
                -->
</section>

</section>

        <section>
            <title>Regex</title>
            
            <para>It is not, in general, advisable to attempt to process arbitrary XML solely with
                regular expressions (regex), but it is not difficult to identify and process markers
                of the kind we are concerned with here.<footnote>
                    <para>In terms of the Chomsky hierarchy, XML is a Type 2 (context-free) grammar
                        and regular expressions are a Type 3 (regular) grammar. Parsing a
                        context-free grammar, which permits recursion, requires a stack, which is
                        not available in regular grammars. While some modern regular expression
                        implementations support back-referencing and recursion and thus go beyond
                        the limitations of a Chomsky regular grammar, whether methods that rely on
                        these extensions should be considered regular-expression parsing is unclear
                        (this is a theoretical issue), as is the role of legibility in evaluating
                        the suitability of the method to the task (this is a practical
                        concern).</para>
            </footnote></para>
            
            <para>The following regex matches start-markers:</para>
            
            <figure>
                <programlisting>(&lt;[^&gt;]+?)th:sID\s*=\s*['"]\w+?['"](.*?)\/(&gt;)</programlisting>
                <caption>
                    <para>Regex to match start-markers</para>
                </caption>
            </figure>
            
            <para>The regex works as follows (in <emphasis role="ital">dot-all</emphasis> mode, that
                is, where dot also matches <code>\n</code>):<itemizedlist>
                    <listitem>
                        <para>The first capture group matches everything from the beginning of a tag
                            that contains a <code>@th:sID</code> attribute until that attribute
                            name. This necessarily includes the space that precedes the attribute
                            name, as well as any attributes that might also precede it.</para>
                    </listitem>
                    <listitem>
                        <para>We do not capture any part of the <code>@th:sID</code> attribute: the
                            attribute name, the equal sign (with optional whitespace before or
                            after), the quotation mark value delimiter (single or double), the
                            attribute value (all characters up to the closing value delimiter), and
                            the closing value delimiter. As long as the <code>@th:sID</code> and
                                <code>@th:eID</code> values are created with the XPath
                                <code>generate-id()</code> function, they cannot contain single or
                            double quotation marks (<code>generate-id()</code> creates only values
                            that are XML names), so we do not need to verify that the opening and
                            closing delimiters match each other lexically.<footnote>
                                <para>“The returned identifier must consist of ASCII alphanumeric
                                    characters and must start with an alphabetic character. Thus,
                                    the string is syntactically an XML name.” [<xref linkend="xpath"
                                    />, <link
                                        xlink:href="https://www.w3.org/TR/xpath-functions-31/#func-generate-id"
                                        >§14.5.4</link>]</para>
                            </footnote></para>
                    </listitem>
                    <listitem>
                        <para>The second capture group captures everything following the
                                <code>@th:sID</code> attribute up to the <code>/&gt;</code> that
                            marks the end of the tag.</para>
                    </listitem>
                    <listitem>
                        <para>We do not capture the <code>/</code> before the closing
                                <code>&gt;</code>.<footnote>
                                <para>Forward slash has to be escaped in some regex implementations,
                                    but not in others. Escaping where it is not required does no
                                    harm.</para>
                            </footnote></para>
                    </listitem>
                    <listitem>
                        <para>The third capture group captures the closing <code>&gt;</code>.</para>
                    </listitem>
            </itemizedlist></para>
            
            <para>We replace all matches with the following
            replacement pattern:</para>
            
            <figure>
                <programlisting>\1\2\3</programlisting>
                <caption>
                    <para>Replacement pattern for start-markers</para>
                </caption>
            </figure>
            
            <para>The regex to match end-markers is similar to the one for start-markers, and
                because real end-tags cannot contain attributes, we do not need to match or copy
                them. We capture the opening <code>&lt;</code> separately from whatever follows it,
                so that we can write a <code>/</code> into the replacement after it. The regex
            is:</para>
            
            <figure>
                <programlisting>(&lt;)(\S+?)\s+[^&gt;]*?th:eID=['"]\w+['"][^&gt;]*?\/(&gt;)</programlisting>
                <caption>
                    <para>Regex to match end-markers</para>
                </caption>
            </figure>
            
            <para>and the replacement pattern is:</para>
            
            <figure>
                <programlisting>\1/\2\3</programlisting>
                <caption>
                    <para>Replacement pattern for end-markers</para>
                </caption>
            </figure>
            
            <para>This method will incorrectly apply the replacement to matching patterns within XML
                comments and CDATA marked sections. With insincere apologies for disappointing Regex
                Edge-Case Bounty Hunters, coping with matches in these contexts, which would not
                naturally appear in our data, is not a goal in our work.<footnote>
                    <para>Similarly, we rely on the use of <code>th:</code> as the namespace prefix
                        and <code>th:sID</code> and <code>th:eID</code> as the attribute names for
                        our Trojan attributes. Changing these assumptions is not a problem as long
                        as the regex is changed to match.</para>
            </footnote></para>
            
            <para>A more serious limitation of this method is that because it is not XML-aware, it
                can be used only in situations where raising is guaranteed not to create overlap.
            For example, given input like:</para>
            
            <figure>
                <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;root xmlns:th="http://www.blackmesatech.com/2017/nss/trojan-horse"&gt;
    &lt;page th:sID="page1"/&gt;
    &lt;para th:sID="para1"/&gt;Content on page 1 in paragraph 1 
    &lt;page th:eID="page1"/&gt;
    &lt;page th:sID="page2"/&gt;Content on page 2 in para 1 
    &lt;para th:eID="para1"/&gt;
    &lt;para th:sID="para2"/&gt;Content on page 2 in para 2
    &lt;para th:eID="para2"/&gt;
    &lt;page th:eID="page2"/&gt;
&lt;/root&gt;</programlisting>
                <caption>
                    <para>XML that cannot be unflattened without creating overlap</para>
                </caption>
            </figure>
            
            <para>the result of converting all markers to real start-
            and end-tags would be:</para>
            
            <figure>
                <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;root&gt;
    &lt;page&gt;
        &lt;para&gt;Content on page 1 in paragraph 1 
    &lt;/page&gt;
    &lt;page&gt;Content on page 2 in para 1 
        &lt;/para&gt;
        &lt;para&gt;Content on page 2 in para 2&lt;/para&gt;
    &lt;/page&gt;
&lt;/root&gt;</programlisting>
                <caption>
                    <para>Invalid (overlapping) result of converting all markers to real start- and
                        end-tags</para>
                </caption>
            </figure>
            
            <para>The resulting document is not well-formed because the pages and paragraphs
                overlap. It is, however, possible to raise just pages but not paragraphs, or just
                paragraphs but not pages, without creating overlap, and the result would be
            well-formed.</para>
            
            </section>
            
        <section>
            <title>Pull parsing in Python</title>
            
            <para>The Python <code>xml.dom.pulldom</code> module can be used to stream an XML
                document past an event handler that can be instructed to raise a flattened hierarchy.<footnote>
                    <para>The authors are grateful to Ronald Haentjens Dekker for bringing this
                        method to our attention. The example at his
                            <link>https://github.com/rhdekker/python_xml_pull_parser_example</link>
                        GitHub repository is a partial model for the examples here, and we
                        appreciate his assistance in debugging the Trojan attribute pitfall
                        described below under <xref linkend="python_xml_challenges"/>.</para>
                </footnote> The result of pull parsing can be fashioned into output in two ways,
                as a string or as XML. With string output, it passes all events through unchanged
                except for markers, which it replaces with regular XML start- and end-tags. Because
                the output construction is not XML-aware, it has the same limitations as the regex
                approach: most significantly, it is capable of creating output that includes
                overlap, and that therefore is not well formed XML. With XML output, though, we use
                    <code>xml.dom.minidom</code> to create XML elements within a DOM structure,
                which means that the result is necessarily well-formed. Pull parsing operates as a
                single traversal, which is to say that it begins at the document node and touches
                each element only once. With string output, the procedure can create write output as
                it handles each event; with XML output it is necessary to maintain the current
                context in a stack, which is similar to the use of a stack in the <xref
                    linkend="accumulators"/> method described above.<footnote>
                    <para>We buffer output by writing it to a list, which we stringify and write all
                        at once at the end, saving the overhead of repeated write operations. With
                        large documents and low memory, though, the method can easily be modified to
                        stream the output to the filesystem.</para>
                </footnote> The maximum depth of the stack is equal to the maximum depth of nesting
            in the hierarchical XML. </para>
            
            <section>
                <title>String output</title>
                
                <para>The following Python 3 code replaces markers with strings equivalent to real
                XML start- and end-tags:</para>
                
                <figure>
                    <!--* Lines are long and should be broken.
                      * I can't do it because I don't remember
                      * Python's conventions for line continuation.
                      
                      djb: "Long" is in the eye of the beholder; The longest (the first) is 79 characters,
                      which would have been long on my first 80-character monitor, but on all but ancient hardware,
                      I think these are short enough that wrapping would make them harder to read.
                      *-->
                    <programlisting>import sys
from xml.dom.pulldom import CHARACTERS, START_ELEMENT, parseString, END_ELEMENT

def entities(input):
    return input.replace('&amp;', '&amp;amp;').replace('&lt;', '&amp;lt;').replace('&gt;', '&amp;gt;')
output = []
with open(sys.argv[1], 'r') if len(sys.argv) > 1 else sys.stdin as input:
    for event, node in parseString(input.read()):
        if event == START_ELEMENT:
            if node.hasAttribute('th:eID'): 
                # Trojan end tag
                output.append('&lt;/')
            else: 
                # Trojan start tags and non-Trojan elements
                output.append('&lt;')
            output.append(node.nodeName)
            for attname, attvalue in node.attributes.items(): 
                # remove Trojan attributes and namespace declaration
                if not (attname.startswith('th:') or attname == 'xmlns:th'):
                    output.append(' ' + attname + '="' + attvalue + '"')
            output.append('>')
        if event == END_ELEMENT:
            if not (node.hasAttribute('th:sID') or node.hasAttribute('th:eID')): 
                # non-Trojan only
                output.append('&lt;/' + node.nodeName + '>')
        elif event == CHARACTERS:
            output.append(entities(node.data))
print("".join(output))</programlisting>
                    <caption>
                        <para>Python code that constructs the XML output as a string</para>
                    </caption>
                </figure>
                
                <para>We create an empty list to hold the output, read in the source, and examine
                    each event. In this simplified example, we process only
                        <code>START_ELEMENT</code>, <code>END_ELEMENT</code>, and
                <code>CHARACTERS</code>, as follows:</para>
                
                <itemizedlist>
                    <listitem>
                        <para><code>START_ELEMENT.</code> Markers with <code>@th:eID</code>
                            attributes are flattened end-tags, so when we encounter one, we output
                                <code>&lt;/</code>; for other <code>START_ELEMENT</code> events we
                            output only <code>&lt;</code>. We follow this with the gi
                                (<code>node.nodeName</code>) and then iterate over the attributes.
                            For each non-Trojan attribute, we output a space, the attribute name, an
                            equal sign, and the attribute value in quotation marks. Finally, we
                            output the closing <code>&gt;</code>.</para>
                    </listitem>
                    <listitem>
                        <para><code>END_ELEMENT.</code> Although markers are sole-tags, they fire
                            both <code>START_ELEMENT</code> and <code>END_ELEMENT</code> events.
                            Since we process all markers at their <code>START_ELEMENT</code> events,
                            we ignore their <code>END_ELEMENT</code> events. For other
                                <code>END_ELEMENT</code> events, we create a regular end-tag.</para>
                    </listitem>
                    <listitem>
                        <para><code>CHARACTERS.</code> We add character data content to the output,
                            explicitly replacing reserved characters with XML entities.</para>
                    </listitem>
                </itemizedlist>
                
                <para>We are parsing the input XML in an XML-aware manner, which is reasonably
                    robust, but we are constructing the output XML as a string, which is not. See
                    below <xref linkend="python-string-challenges"/> for a discussion of the limitations.</para>
                
                </section>
                
            <section>
                <title>XML output</title>
                
                <para>The general approach to parsing with <code>pulldom</code> and constructing
                    output with <code>minidom</code> is similar to the <xref linkend="accumulators"
                    /> method described above. Specifically, the flattened XML is traversed in a
                    single pass from left to right (technically a depth-first traversal, which is
                    how <code>pulldom</code> sees it) and events (we focus on
                        <code>START_ELEMENT</code>, <code>END_ELEMENT</code>, and
                        <code>CHARACTERS</code>) are handled as they occur. The output is assembled
                    in memory as a tree, using <code>minidom</code> to create and attach nodes as
                    needed. Open elements are stored on a stack, the maximum depth of which is,
                    therefore, equal to the maximum depth of the unflattened XML. The code
                is:</para>
                
               <figure> <programlisting>from xml.dom.pulldom import CHARACTERS, START_ELEMENT, parseString, END_ELEMENT
from xml.dom.minidom import Document


class Stack(list):
    def push(self, item):
        self.append(item)

    def peek(self):
        return self[-1]


open_elements = Stack()
d = Document()
open_elements.push(d)

with open('flattened.xml') as input:
    for event, node in parseString(input.read()):
        if event == START_ELEMENT:
            if not node.hasAttribute('th:eID'): # process pseudo-end-tags on END_ELEMENT event
                open_elements.peek().appendChild(node)
                open_elements.push(node)
        elif event == END_ELEMENT:
            if node.hasAttribute('xmlns:th'): # don't declare now-unused th: namespace
                node.removeAttribute('xmlns:th')
            if node.hasAttribute('th:sID'): # can't remove @start until we're done with the node
                node.removeAttribute('th:sID') 
            else: # pop only on container elements and Trojan end-tags
                open_elements.pop()
        elif event == CHARACTERS:
            t = d.createTextNode(node.data)
            open_elements.peek().appendChild(t)

                print(open_elements.pop().toxml())</programlisting>
               <caption><para>Raising with python using pulldom</para></caption>
               </figure>
                
                <para>Parsing is the same as described above, so we import the same items from
                        <code>pulldom</code>. From <code>minidom</code> we import only the
                        <code>Document</code> class, which we use to initialize our output XML
                    document. Our <code>Stack</code> class is a Python list adorned with
                    stack-idiomatic terminology: we alias <code>append()</code> as
                        <code>push()</code> (lists already have a <code>pop()</code> method), and we
                    add <code>peek()</code> to provide access to the item at the top of the stack.
                    That top item is the most recently opened element, and we peek at it in order to
                    append child elements and child <code>text()</code> nodes as we encouter them.
                    We begin by pushing the document node onto the
                stack.</para>
                
                <para>We handle <code>START_ELEMENT</code>, <code>END_ELEMENT</code>, and
                        <code>CHARACTERS</code> events in an <code>if/elif/elif</code> structure,
                    silently ignoring other events. There are three types of elements whose start
                    and end events we need to process: start-markers, end-markers, and regular
                elements (whether empty or not).</para>
                
                <itemizedlist>
                    <listitem>
                        <para>In the case of start-markers and regular elements, we append the new
                            node as a child of the item at the top of the stack (initially the
                            document node; thereafter an element node) and then push the node onto
                            the stack so that it becomes the new context element. The
                                <code>appendChild()</code> and <code>push()</code> operations serve
                            different but related purposes. Appending the new node to the current
                            context (whatever is at the top of the stack) adds it to the correct
                            location on the eventual output tree. Pushing it makes it the new
                            current context, so that subsequent nodes will be added to it as
                            children as long as it remains the current context. Nodes are
                            passed by reference, rather than by value, so after these operations we
                            point to the same new current node from three places: 
                            <orderedlist>
                                <listitem><para>the original input document,</para></listitem>
                                <listitem><para>the top of the stack</para></listitem>
                                <listitem><para>the location in the tree we are
                            assembling under the output document node, which is at the bottom of the
                            stack.</para></listitem>
                            </orderedlist></para>
                        <para>We ignore <code>START_ELEMENT</code> events for end-markers; all of
                            their processing happens on their <code>END_ELEMENT</code> event. This
                            is a somewhat arbitrary decision.</para>
                    </listitem>
                    <listitem>
                        <para>The three mutually exclusive clauses in the <code>if/elif/elif</code>
                            block that processes <code>END_ELEMENT</code> events work as
                            follows:</para>
                        <itemizedlist>
                            <listitem>
                                <para><code>minidom</code> treats namespace declarations as
                                    attributes, so the presence of an attribute with the name
                                        <code>xmlns:th</code> identifies the root note.<footnote>
                                        <para>It is legal to declare namespaces redundantly even
                                            where their declarations are already in force because
                                            they are inherited from a higher level in the tree. If
                                            accommodating a redundant declaration of the
                                                <code>th:</code> namespace is required, the code
                                            could be modified to do that by revising the
                                                <code>if/elif/elif</code> logic.</para>
                                    </footnote> In our examples we are raising all markers, and
                                    therefore removing all attributes in the Trojan namespace, so we
                                    remove this declaration to avoid the clutter of an unneeded
                                    namespace declaration in the output. Because we identify Trojan
                                    attributes by their lexical shape (that is, by the presence of
                                    an explicit <code>th:</code> prefix), removing the namespace
                                    declaration early in the processing does not impinge on our
                                    ability to identify attribute instances that use the prefix.
                                    Because we never pop the root element, it will be at the top of
                                    the stack when our processing concludes.</para>
                            </listitem>
                            <listitem>
                                <para>We remove the Trojan <code>@th:sID</code> attribute from the
                                    start-marker. We want to remove it eventually because it is not
                                    needed in the output, but we cannot remove it until the
                                        <code>END_ELEMENT</code> event of the start-marker because
                                    its presence tells us not to pop the stack at that
                                        <code>END_ELEMENT</code> event. In this way we push the
                                    element we are currently raising onto the top of the stack at
                                    its start-marker, but we remove its Trojan attributes only when
                                    we pop it at the <code>END_ELEMENT</code> event of the
                                    end-marker.</para>
                            </listitem>
                            <listitem>
                                <para>The first two clauses process the root element and
                                    start-markers, both of which we leave on the stack after their
                                        <code>END_ELEMENT</code> events. In the remaining cases
                                    (end-markers and regular elements, whether empty of not), we pop
                                    the stack at the <code>END_ELEMENT</code> event, which makes its
                                    parent in the output tree where we are constructing the current
                                    context for the next event.</para>
                            </listitem>
                        </itemizedlist>
                    </listitem>
                    <listitem>
                        <para>In the case of <code>CHARACTERS</code>, we create a
                                <code>text()</code> node and append it as a child of the current
                            context, that is, the element at the top of the stack. When we wrote
                            string output earlier we had to convert reserved characters to character
                            entities ourselves, but in this case we are writing XML output, so the
                            system automatically performs the entity encoding for us.</para>
                    </listitem>
                </itemizedlist>
                
                <para>Conceptually, the entire start-marker functions as if it were the
                        <code>START_ELEMENT</code> event for a regular element, and the entire
                    corresponding end-marker functions as if it were the <code>END_ELEMENT</code>
                    event for the same regular element. This means that we push a start-marker on
                    its <code>START_ELEMENT</code> event (ignoring its <code>END_ELEMENT</code>
                    event, except to remove its Trojan attribute), and pop it on the corresponding
                    end-marker’s <code>END_ELEMENT</code> event (ignoring its
                        <code>START_ELEMENT</code> event). In tabular
                form:</para>
                
                <table>
                    <thead>
                        <tr>
                            <th>Element type</th>
                            <th>
                                <code>START_ELEMENT</code>
                            </th>
                            <th>
                                <code>END_ELEMENT</code>
                            </th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <th>Regular</th>
                            <td>Push</td>
                            <td>Pop</td>
                        </tr>
                        <tr>
                            <th>Start-marker</th>
                            <td>Push</td>
                            <td>Remove <code>@th:sID</code></td>
                        </tr>
                        <tr>
                            <th>End-marker</th>
                            <td>Ignore</td>
                            <td>Pop</td>
                        </tr>
                    </tbody>
                </table>
            </section>
            
        </section>
        
    </section>
    
    <section xml:id="errors">
        <title>Some things that can go wrong</title>
        
        <para>Each of the methods described above comes with its own complications, and it was in
            the discussion of these complications that this paper originated. Some of these are
            challenges that can be overcome, others are limitations in what the method can manage,
            and others are deal-breakers that show that the method is not ultimately suitable for
            realistic use cases. In this section we review briefly the complications for each
        method.</para>
        
        <section xml:id="errors-rst">
            <title>Right-sibling traversal</title>
            <para>Two elusive bugs in an initial implementation of the right-sibling traversal
                algorithm took the better part of a day or two to identify:</para>
            <itemizedlist>
                <listitem>
                    <para>It is remarkably easy to write
                            <code>select="following-sibling::node()"</code> instead of
                            <code>select="following-sibling::node()[1]"</code>, and remarkably easy
                        to overlook the error when scanning the code looking for the reason that the
                        output is an order of magnitude larger than the input instead of
                        approximately the same size. The symptom is that single nodes in the input
                        appear more than once in the output.</para>
                </listitem>
                <listitem>
                    <para>Similarly, it is remarkably easy to write <code>&lt;xsl:apply-templates
                            select="..."/></code> instead of <code>&lt;xsl:apply-templates
                            select="..." mode="raising"/></code>. The symptom is the reverse
                        of the preceding: some nodes in the input drop out of the output.</para>
                </listitem>
            </itemizedlist>
            <para>
                <emphasis>[Fuller examination of the version-control history of the stylesheets will
                    probably reveal further errors, a discussion of which may be
                    illuminating.]</emphasis>
            </para>
        </section>
        
        <section xml:id="recursion_challenges" xreflabel="Inside-out recursion challenges">
            <title>Inside-out recursion</title>
            <para>The two principal pitfalls with inside-recursion are <emphasis role="ital">double
                    processing</emphasis> and <emphasis role="ital">endless
                recursion</emphasis>.</para>
            <section>
                <title>Double processing</title>
                <para>When a start-marker is matched and raised, the nodes that belong inside the
                    new container are copied into it inside the template that matches the
                    start-marker. Because the nodes being copied are also candidates for the
                    application of templates in the current pass through the function, we need to
                    match them (along with the end-marker) in an empty
                        <code>&lt;xsl:template&gt;</code> in order to avoid outputting them twice.
                    Otherwise they would be copied when the start-marker is matched and then
                    processed again when templates are applied to them in their own right.</para>
            </section>
            <section>
                <title>Endless recursion</title>
                <para>Recursion requires an exit condition to avoid falling into an endless loop. In
                    an early version of the code, the recursive function tested for the presence of
                    Trojan milestone attributes, and if there weren’t any, it concluded that all
                    raising had been completed and stopped the recursion. This test fails in
                    situations where there are Trojan elements that cannot be raised without
                    creating overlap. Avoiding the endless loop in such situations requires a more
                    complex test, not just for the presence of Trojan attributes, but for the
                    presence of those that can be raised without creating overlap. In our simplified
                    sample, instead of testing for <code>exists($input//@th:sID)</code>, we test for
                    elements that can be raised without risk of overlap with:</para>
                <figure>
                    <programlisting>exists($input//*[@th:sID eq following-sibling::*[@th:eID][1]/@th:eID])</programlisting>
                    <caption>
                        <para>Test for markers that can be raised without creating overlap</para>
                    </caption>
                </figure>
                <para>Endless recursion is not an issue in situations where complete raising would
                    not create overlap. This is the case with our original simplified sample, where
                    the XML with Trojan markup was created by flattening original hierarchical XML,
                    and since the original could not have had overlap, it can be reconstructed
                    safely. Endless recursion is also not a problem when we raise only a subset of
                    the markup that is guaranteed not to overlap. For example, if we have
                    tessellated page and paragraph hierarchies over a prose text, where both pages
                    and paragraphs have been flattened, we cannot fully raise all instances both
                    types of elements if doing so would create overlap. But if our markup convention
                    is that pages cannot overlap with pages and paragraphs cannot overlap with
                    paragraphs, we can modify the raising routine to raise only the pages or only
                    the paragraphs. See also <xref linkend="tessellated"/>, where we discuss an
                    alternative approach to raising with data of this type.</para>
            </section>
        </section>
        
        <section xml:id="errors-accumulators">
            <title>Accumulators</title>
            <para>The primary problems we encountered in our implementation using accumulators were: <itemizedlist>
                    <listitem>
                        <para>Failure to use a fully implemented XSLT 3.0 processor. Initial tests
                            used Saxon HE 9.6.0.5, which does not complain or warn about
                                <code>version="3.0"</code>, but which appears not to support all of
                            the 3.0 constructs used. The main symptom was an error message reporting
                            that <quote>XTSE0010: Element xsl:mode must not appear directly within
                                xsl:stylesheet</quote> (which led to a wild goose chase through the
                            3.0 spec trying to locate constraints on where mode declarations are
                            allowed), followed unobtrusively by the message <quote>XTSE0010: Unknown
                                XSLT element: mode</quote>. Upgrading to Saxon 9.8.0.12 solved this
                            problem.</para>
                    </listitem>
                    <listitem>
                        <para>Failure to specify <code>@use-accumulators</code>.</para>
                        <para>The next problem was the persistent repetition of the error message
                                <quote>Accumulator stack is not applicable to the current
                                document</quote>. Several attempts of increasing complexity (and, to
                            be honest, decreasing plausibility) to make it applicable failed, until
                            eventually it became clear that the only thing needed was to specify
                                <code>use-accumulators="stack"</code> on the mode declaration for
                            the default unnamed mode. (The mode declaration was already present; had
                            it not been, it would have needed to be introduced.)</para>
                    </listitem>
                </itemizedlist></para>
        </section>
        
        <section xml:id="errors-regex">
            <title>Regex</title>
            <para>The principal challenge to writing the regex (aside from the risk of inadvertently
                creating XML that is not well-formed because of overlap, which is discussed above)
                is anticipating variation in the markup. For example, an XML start-tag with a single
                attribute looks like <code>&lt;gi attname="value"&gt;</code>, but it allows optional
                whitespace around the equal sign and before the closing <code>&gt;</code>
                delimiter—but not between the opening <code>&lt;</code> delimiter and the generic
                identifier, and not between the <code>/</code> and the <code>&gt;</code> at the end
                of a self-closing empty tag. Where it allows whitespace, it allows any amount of any
                combination of whitespace characters.</para>
            <para>Within the context of a single project, the easiest way to deal with the allowable
                variation is not to allow it, that is, to enforce rigorous consistency even where
                XML syntax does not require it. But because rigorous consistency is difficult to
                achieve without computational validation, we opted for a more robust regex—that is,
                one more accepting of variation, even though allowing for variation made the regex
                harder to read and develop.</para>
            <para>The regex expressions needed to raise <emphasis role="ital"
                    >Frankenstein</emphasis> are slightly more complex because they may or may not coexist with other attributes on a given element node.</para>
        </section>
        
        <section xml:id="python-string-challenges">
            <title>Pull parsing in Python</title>
            <para>The Python pull parser reads the input XML as XML and responds to parse events. We
                handle <code>START_ELEMENT</code>, <code>END_ELEMENT</code>, and
                    <code>CHARACTERS</code>, and ignore other events, and we use XML-aware methods
                to access attributes. With respect to managing the input, then, this is a reasonably
                robust strategy. The quality of the output handling depends on whether we create
                output as a string or as an XML DOM.</para>
            <section>
                <title>String output</title>
                <para>Creating XML output as a string is a brittle strategy. Not only is it
                    susceptible to writing overlapping tags for the same reason as the regex method
                    described earlier, but we also explicitly wrap attribute values in double-quote
                    characters (<code>"</code>), which will produce results that are not well-formed
                    if the attribute value happens to have contained the double-quote character
                    originally. Python has an escape mechanism that is capable of dealing with
                    awkwardly nested single- and double-quote characters in strings, as does XML,
                    but the Python escape strategy is different from the XML one, and the code to
                    perform the string manipulation needed to mediate between the two is difficult
                    to read and write. Furthermore, where output is created as a string, we have to
                    replace reserved characters with character entities explicitly ourselves, while
                    XML-aware output does that automatically. For those reasons, it is safer to use
                    XML methods to create the XML output as a (necessarily well-formed) DOM tree,
                    which can then be serialized, instead of creating the output directly as a
                    string. The use of <code>pulldom</code> to parse the input XML also requires
                    accommodations to the peculiarities of <code>pulldom</code> namespace handling,
                    which are discussed immediately below, under <xref
                        linkend="python_xml_challenges"/>.</para>
            </section>
            <section xml:id="python_xml_challenges" xreflabel="Python XML output challenges">
                <title>XML output</title>
                <para>Generating XML output with Python <code>minidom</code> is reasonably robust
                    and straightforward, but potentially confusing for the following reasons:</para>
                <itemizedlist>
                    <listitem>
                        <para>The pull parser responds not to start- and end-tags, but to
                                <code>START_ELEMENT</code> and <code>END_ELEMENT</code> events.
                            Although markers are single tags (sole-tags), they fire both events, one
                            immediately after the other. Since a start-marker and an end-marker both
                            fire both types of events, dealing with the two different senses of
                                <emphasis role="ital">start</emphasis> and <emphasis role="ital"
                                >end</emphasis> (marker vs event) simultaneously is potentially
                            confusing for the developer. We also need to decide whether to process
                            the marker at the <code>START_ELEMENT</code> or <code>END_ELEMENT</code>
                            event, or to divide the processing of a marker over the two events.
                            Since the two events always follow each other immediately, it might seem
                            not to matter, but that assumption led us into error when dealing with
                            removing Trojan attributes, about which see the following issue.</para>
                    </listitem>
                    <listitem>
                        <para>Attributes in <code>minidom</code> are part of a dictionary-like
                            property of the element node. We had decided (somewhat arbitrarily) to
                            process start-markers at the <code>START_ELEMENT</code> event, and we
                            wanted to remove Trojan attributes from those elements when we raised
                            them. Initially we removed them when processing the
                                <code>START_ELEMENT</code> event without noticing that we use them
                            as part of the decision process on <code>END_ELEMENT</code> events.
                            Because <code>minidom</code> objects are mutable, once we had removed
                            the attribute at the <code>START_ELEMENT</code> event it was no longer
                            available when we needed to test for it at the <code>END_ELEMENT</code>
                            event, which led to errors in our stack management. We fixed the problem
                            by removing the Trojan attributes only at the <code>END_ELEMENT</code>
                            event. An alternative strategy, which also worked under testing, was to
                            clone the node at the <code>START_ELEMENT</code> event, remove the
                            Trojan attributes from the clone, and add the clone to the output tree
                            and the stack. Since this approach does not remove anything from the
                            original node, any original Trojan attribute is still available for
                            testing when the <code>END_ELEMENT</code> event fires.</para>
                    </listitem>
                    <listitem>
                        <para>The relationships among namespaces, namespace prefixes, and namespace
                            declarations in <code>minidom</code> are alien to the XML view of
                            namespaces. While <code>minidom</code> is namespace-aware at the level of the
                            model, that awareness is not integrated with the serialization
                            supported by the <code>toxml()</code> method (and some others). Here is
                            a partial summary of the details:</para>
                        <itemizedlist>
                            <listitem>
                                <para>Whether <code>minidom</code> writes a namespace prefix into a
                                    serialization depends only on whether the prefix was specified
                                    when the element was created. It has nothing to do with whether
                                    the element is really in a namespace. It is possible to create
                                    and serialize an element with a namespace prefix that is not
                                    really in the namespace. It is also possible to create an
                                    element in a namespace without a prefix and when you serialize
                                    it, it will emerge without a prefix even if the namespace is not
                                    in scope, which means that when the serialization is parsed
                                    downstream, the element will be in whatever the default
                                    namespace is for its context.</para>
                            </listitem>
                            <listitem>
                                <para><code>minidom</code> will not write namespace declarations
                                    (default or prefix-binding) unless you create them explicitly as
                                    attributes. This means that you can create an element with a
                                    prefix and serialize output where the prefix is not actually
                                    declared, which is not well-formed.</para>
                            </listitem>
                            <listitem>
                                <para><code>minidom</code> will let you create and serialize an
                                    element with a namespace prefix with
                                        <code>createElement()</code> even though the element is not
                                    really in a namespace. An element is in a namespace only if it
                                    is created with <code>createElementNS()</code>.</para>
                            </listitem>
                            <!--This needs to be tested; it may not be fully correct as written.
                                
                                <listitem>
                                <para>Matching a namespaced node (such as a Trojan
                                        <code>@th:sID</code>) requires matching it as it is spelled.
                                    This can be done with <code>getAttribute('th:sID')</code> or
                                        <code>getAttributeNS('http://www.blackmesatech.com/2017/nss/trojan-horse','th:sID')</code>.
                                    You cannot match it with
                                        <code>getAttributeNS('http://www.blackmesatech.com/2017/nss/trojan-horse','sID')</code>
                                    even if you have bound the <code>th:</code> prefix to the
                                        <code>http://www.blackmesatech.com/2017/nss/trojan-horse</code>
                                    namespace URI.</para>
                            </listitem>-->
                        </itemizedlist>
                        <para>Because <code>pulldom</code> and <code>minidom</code> are essentially
                            blind to namespace declarations, this also means that when we remove the
                            declaration of the Trojan namespace while processing the root element
                            (which changes the in-memory tree because <code>pulldom</code> and
                                <code>minidom</code> objects are mutable), we can nonetheless still
                            find Trojan attributes by their lexical shape, that is, by their
                            explicit prefixes. It also means that our code is depending on those
                            lexical forms: we rely on the presence of an explicit declaration of the
                            Trojan namespace prefix only on the root element, and we rely on the use
                            of the string <code>th:</code> as the namespace prefix. This means that
                            XML that expresses the same namespace information in different ways
                            (e.g., by binding a different prefix to the namespace URI, or by using
                            namespace declarations on individual elements, instead of a prefix) will
                            not be processed correctly.</para>
                        <para>These <code>pulldom</code> and <code>minidom</code> behaviors are
                            far from XML-idiomatic, but except for the syntactic dependencies they
                            impose (where namespaces are declared, how the declarations are spelled,
                            how they are bound to prefixes), they prove not to be much of a
                            practical obstacle during processing. The required accommodation entails
                            writing namespace prefixes and namespace declarations (using
                            attribute-like syntax) explicitly where we want them in the output, and
                            matching namespaced elements and attributes with the prefix where it is
                            used in the serialized input and without the prefix where it is
                            not.</para>
                    </listitem>
                </itemizedlist>
            </section>
        </section>
        
    </section>
    
    <section xml:id="comparisons">
        <title>Comparison</title>
        
        <para>The inside-out recursive approach (both the function-based XSLT 3.0 version and
            named-template-based XSLT 1.0 one) is tail-recursive, which means that an XSLT processor
            that performs tail-call optimization will not be at risk for running out of stack space.
            In cases where tail-call optimization is not available, the maximum depth of recursion
            is equal to the <emphasis role="ital">depth</emphasis> of the deepest marker in the
            input (pseudo-)hierarchy. The right-sibling traversal approach (both the XSLT 3.0 and
            the XSLT 1.0 versions) is also tail-recursive, and with an XSLT parser that does not
            perform tail-call optimization, it requires stack space equal to the maximum <emphasis
                role="ital">width</emphasis> of the widest
        hierarchical level.</para>
        
        <para>Insofar as an open-source XSLT 3.0 processor that performs tail-call optimization is
            freely available in the open-source, platform-independent Saxon-HE product [<xref
                linkend="saxon"/>], the difference in stack requirements between the two methods has
            not been a consideration for our purposes. But insofar as XML documents of the sort that
            are of interest to digital humanists are typically wider than they are deep, users who
            are unable to employ an XSLT processor that performs tail-call optimization may favor
            inside-out processing over right-sibling traversal because inside-out processing is
        likely to require less stack space.</para>
        
        <para>Developing the XSLT to reconstruct elements from the inside out may be more efficient
            than to do so from the outside in. Attempts to write code that does not control the
            order of processing must always account for the potential presence of intervening nodes
            to be reconstructed on the inside, that risk becoming duplicate (or triplicate, or
            quadruplicate, etc) nodes in the output depending on the depth of the hierarchy to be
        reconstructed.</para>
        
        <para>
            <emphasis role="ital">[Comparison of other methods to be added]</emphasis>
        </para>
        
        <!--<para>TODO: Unassigned: [Measurement of time and space complexity running all solutions on
            the same data (as large as we can manage—e.g., all of <emphasis role="ital"
                >Frankenstein</emphasis>, or an artificial document containing 10 or 100 copies of
                <emphasis role="ital">Frankenstein</emphasis>).]</para>
        <para>TODO: Unassigned: [Time complexity is easy enough to measure; space complexity may be
            harder, but we may be able to find ways. I believe that the Unix tool <emphasis
                role="bold">top</emphasis> gives the current memory usage of a task, so the
            information is certainly available.]</para>
        <para>TODO Unassigned: [One reason I would like to have multiple XSLT 1.0 solutions is so
            that we can test performance in more than one implementation: <emphasis role="bold"
                >xsltproc</emphasis>, <emphasis role="bold">Xalan</emphasis>, and browser XSLT
            engines, if we can figure out how to persuade a browser to do the work.</para>
        <para>TODO Unassigned: [My prediction a priori is that using <emphasis role="bold"
                >sed</emphasis>, <emphasis role="bold">emacs</emphasis>, <emphasis role="bold"
                >perl</emphasis>, or <emphasis role="bold">Python</emphasis> to make the changes
            with regular expressions will be much faster than using XSLT. Without XSLT, it will be
            much easier to produce output that’s not well-formed; it would be good to document how
            many attempts are needed before our sed script is producing well-formed output, and how
            many more are needed before it’s both well formed and correct. djb: I spent about an
            hour crafting and debugging the regex expressions for the start and end tags. It
            produces well-formed output with my baby sample, recreating the original document
            (before flattening) faithfully. I look forward to the Frankentest!]</para>-->
    </section>
    
    <section>
        <title>Conclusion</title>
        
        <para>None of the methods described here is new, but their explicit juxtaposition,
            comparison, and evaluation in a tutorial context based on real use cases has clarified
            much about micropipelining for the author, and, it is hoped, for the reader, as
        well.</para>
        
    </section>
    
    <appendix xml:id="tessellated">
        <title>Raising tessellated hierarchies</title>
        
        <para>Raising tessellated hierarchies is a common requirement for hierarchy <emphasis
                role="ital">inversion</emphasis>.<footnote>
                <para><emphasis role="ital">Tessellated</emphasis> structures cover an entire domain
                    with the same pattern without gaps or self-overlap, much as mosaic tiles might
                    cover an entire floor.</para>
            </footnote> Consider a simple print document that can be understood as containing a
            sequence of pages or a sequence of paragraphs, where each sequence fully covers the
            content without self-overlap, but where the two different element types overlap in a way
            that makes it impossible to use container elements for both. One typical XML workflow
            with such structures involves encoding one hierarchy with XML container elements and the
            other with milestones. For example, a TEI novel transcribed from an original source
            might be structured with <code>&lt;div&gt;</code> elements for chapters, which contain
                <code>&lt;head&gt;</code> elements for chapter titles and <code>&lt;p&gt;</code>
            elements for paragraphs, with page beginnings encoded as empty <code>&lt;pb/&gt;</code>
            elements. If is later becomes necessary to operate on the pages as units, we can
                <emphasis role="ital">invert</emphasis> the markup by transforming the
            page-beginning milestones into page container elements, while flattening the elements
        that demarcate chapters, titles, and paragraphs.</para>
        
        <para>The method described in this appendix differs from those described above because it
            works only where the hierarchy being raised is tessellated. That outcome requirement
            invites the use of <code>&lt;xsl:for-each-group&gt;</code>, which partitions its entire
            domain exhaustively into groups. The same property that makes
                <code>&lt;xsl:for-each-group&gt;</code> suitable for a situation where an entire
            text may be partitioned into tessellated paragraphs or tessellated pages makes it a poor
            choice for the contexts described in the body of this report, where new container
            elements must be created only around small islands of
        content.</para>
        
        <para>
            <emphasis role="ital">[To be completed, with a use case from
                    <link>http://suprasliensis.obdurodon.org</link>]</emphasis>
        </para>
        
    </appendix>
    
    <bibliography>
        <title>Works cited</title>
        
        <bibliomixed xml:id="collatex" xreflabel="CollateX">
            <emphasis role="ital">CollateX: software for collating textual sources.</emphasis>
            <link>https://collatex.net/-</link>
        </bibliomixed>
        
        <bibliomixed xml:id="derose_2004" xreflabel="DeRose 2004">DeRose, Steve. 2004. “Markup
            Overlap: a review and a horse.” Presented at Extreme Markup Languages 2004. Montréal,
            Québec, August 2-6, 2004.
        <link>http://xml.coverpages.org/DeRoseEML2004.pdf</link></bibliomixed>

        <bibliomixed xml:id="atmo" xreflabel="Sperberg-McQueen 2018">
          Sperberg-McQueen,
          C. M. 
          <quote>Representing concurrent document structures using Trojan Horse markup</quote>.
          To be 
          presented at Balisage: The Markup Conference 2018,
          Washington, DC.
          On the Web in the <link xlink:href="http://www.balisage.net/Proceedings/index.html">preliminary proceedings</link>.
        </bibliomixed>  
        
        <bibliomixed xml:id="tei_p5" xreflabel="TEI P5">P5: <emphasis role="ital">Guidelines for
                electronic text encoding and interchange.</emphasis>
        <link>http://www.tei-c.org/guidelines/P5/</link></bibliomixed>
        
        <bibliomixed xml:id="frankenstein" xreflabel="Variorum Frankenstein">Frankenstein <emphasis
                role="ital">Variorum Project.</emphasis>
        <link>https://github.com/PghFrankenstein/Pittsburgh_Frankenstein</link></bibliomixed>
        
        <bibliomixed xml:id="saxon" xreflabel="Saxon-HE">Saxon-HE (home edition).
        <link>http://saxon.sourceforge.net/</link></bibliomixed>
        
        <bibliomixed xml:id="xpath" xreflabel="XPath functions">
            <emphasis role="ital">XPath and XQuery functions and operators 3.1 W3C recommendation 21
                March 2017.</emphasis>
            <link>https://www.w3.org/TR/xpath-functions-31/</link>
        </bibliomixed>
        
    </bibliography>
    
</article>
